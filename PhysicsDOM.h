#ifndef PHYSICSDOM_H
#define PHYSICSDOM_H

// CreateDOM: Schema Generation tool written by John W. Ratcliff, 2017
// Warning:This source file was auto-generated by the CreateDOM tool. Do not try to edit this source file manually!
// The Google DOCs Schema Spreadsheet for this source came from: https://docs.google.com/spreadsheets/d/118I5kdu2XT-6wfCG044937xfEKDyX2oNg04G8Wqi6o0/edit?usp=sharing

#include <stdint.h>


namespace PHYSICS_DOM
{


// Defines a basic 3d vector type
class Vec3
{
public:
	// Declare the constructor.
	Vec3() { }

	// Declare the assignment constructor.
	Vec3(const float &_x,const float &_y,const float &_z)
	{
		x = _x;
		y = _y;
		z = _z;
	}

	float  		x{ 0 }; 											// x axis component of the vector
	float  		y{ 0 }; 											// y axis component of the vector
	float  		z{ 0 }; 											// z axis component of the vector
};


// Defines a basic quaternion data type
class Quat
{
public:
	// Declare the constructor.
	Quat() { }

	// Declare the assignment constructor.
	Quat(const float &_x,const float &_y,const float &_z,const float &_w)
	{
		x = _x;
		y = _y;
		z = _z;
		w = _w;
	}

	float  		x{ 0 }; 											// 
	float  		y{ 0 }; 											// 
	float  		z{ 0 }; 											// 
	float  		w{ 1 }; 											// 
};


// Defines a basic plane equation
class Plane
{
public:
	// Declare the constructor.
	Plane() { }

	// Declare the assignment constructor.
	Plane(const Vec3 &_n,const float &_d)
	{
		n = _n;
		d = _d;
	}

	Vec3 		n{ 0,1,0 };   										// Normal of the plane equation
	float  		d{ 0 }; 											// The distance from the origin of the plane 
};


// Defines a transform; position and rotation as a quaternion
class Pose
{
public:
	// Declare the constructor.
	Pose() { }

	// Declare the assignment constructor.
	Pose(const Quat &_q,const Vec3 &_p)
	{
		q = _q;
		p = _p;
	}

	Quat 		q;  													// Quaternion rotation
	Vec3 		p;  													// Origin position of the pose
};


// Defines an axis aligned bounding box
class Bounds3
{
public:
	// Declare the constructor.
	Bounds3() { }

	// Declare the assignment constructor.
	Bounds3(const Vec3 &_bmin,const Vec3 &_bmax)
	{
		bmin = _bmin;
		bmax = _bmax;
	}

	Vec3 		bmin; 												// Minimum axis of bounding box
	Vec3 		bmax; 												// Maximum axis of bounding box
};


// Defines the type of node we are dealing with
enum NodeType
{
	NT_NODE, 							// The base Node class
	NT_PHYSICS_MATERIAL, 				// A physics material
	NT_GEOMETRY_INSTANCE,  				// Defines an instance of a geometry
	NT_TRIANGLEMESH, 					// Defines the contents of a triangle mesh
	NT_CONVEXHULL ,						// Defines the contents of a convex hull
	NT_HEIGHTFIELD , 					// Defines the contents of a heightfield
	NT_RIGID_BODY,   					// Common properties of both static and dynamic rigid bodies
	NT_RIGID_STATIC, 					// A static rigid body
	NT_RIGID_DYNAMIC,  					// A dynamic rigid body
	NT_BODY_PAIR_FILTERS,  				// A node representing a collection of body pair filters
	NT_JOINT,  							// Base class for a joint
	NT_INSTANCE_COLLECTION,				// Instantiates a collection of nodes
	NT_COLLECTION,   					// Defines a collection of nodes
	NT_SCENE,  							// Defines a collection that gets instantiated on startup into a physics scene
};


// Defines an optional visual mesh binding to a physics node
class VisualBinding
{
public:
	const char * visualName; 									// Name of associated visual mesh
	Pose 		localPose;  											// Local relative pose of visual mesh to corresponding physics node
	Vec3 		localScale;   										// Local relative scale of visual mesh to corresponding physics node
};


// Describes a key-value pair for custom properties on a node
class KeyValuePair
{
public:
	const char * key;  											// They 'key' identifier; what this property is
	const char * value;											// The value of this property; up to each the user to figure out how to interpret each property relative to the keyword
};


// A collection of key/value pair properties relative to a particular category
class AdditionalProperties
{
public:
	const char * category;   									// The category this set of key/value pairs is associated with (example 'physx', 'mujoco', etc.
	uint32_t 	keyValuePairsCount { 0 };
	const KeyValuePair* keyValuePairs;   						// The array of key/value pairs associated with this category
};


// Base class that specifies a unique ID and an optional description name field for an object
class Node
{
public:
	const char * id; 											// Unique Id for this object
	const char * name;   										// Optional name for this object
	NodeType 	type{ NT_NODE };   								// The type of node
	VisualBinding  visual;   									// Optional visual bindings for this node; for exaple some physics components have a corresponding named graphics component
	uint32_t 	additionalPropertiesCount { 0 };
	const AdditionalProperties* additionalProperties;  			// An optional set of properties for this node; a set of key-value pairs for each application/engine specific category
};


// ShortDescription
class MeshScale
{
public:
	Vec3 		scale;  												// Scale of the mesh on the X,Y,Z axes
	Quat 		rotation; 											// Orientation of the mesh as a quaternion
};


// Defines the physical material properties of a surface
class PhysicsMaterial : public Node
{
public:
	// Declare the constructor.
	PhysicsMaterial()
	{
		Node::type = NT_PHYSICS_MATERIAL;
	};

	bool 		disableFriction{ false }; 							// If true, then friction is disabled for the material
	bool 		disableStrongFriction{ false };   					// If true then strong friction is disabled for the material
	float  		dynamicFriction{ 0.5f };  							// The coefficient of dynamic friction.
	float  		staticFriction{ 0.5f }; 							// The coefficient of static friction
	float  		restitution{ 0.5f };  								// The coefficient of resitution.
};


// Describes the data for a convex hull
class ConvexHull : public Node
{
public:
	// Declare the constructor.
	ConvexHull()
	{
		Node::type = NT_CONVEXHULL;
	};

	uint32_t 	pointsCount { 0 };
	const Vec3*	points;											// Array of data points describing the convex hull
};


// Describes the data for a triangle mesh
class TriangleMesh : public Node
{
public:
	// Declare the constructor.
	TriangleMesh()
	{
		Node::type = NT_TRIANGLEMESH;
	};

	uint32_t 	pointsCount { 0 };
	const Vec3*	points;											// Array of vertices for the triangle mesh
	uint32_t 	trianglesCount { 0 };
	const uint32_t* triangles;   								// Array of triangle indices
};


enum GeometryType
{
	GT_BOX_GEOMETRY, 					// A basic sphere primitive
	GT_SPHERE_GEOMETRY,					// A plane 
	GT_CAPSULE_GEOMETRY, 				// A capsule
	GT_PLANE_GEOMETRY,   				// A simple box primitive
	GT_CYLINDER_GEOMETRY,  				// A cylinder 
	GT_CONVEXHULL_GEOMETRY,				// A convex hull geometry
	GT_TRIANGLEMESH_GEOMETRY,  			// A triangle mesh (can only be static, not dynamic)
};


// Base class for all geometries
class Geometry
{
public:
	GeometryType type;   										// 
};


// Defines a box geometry
class BoxGeometry : public Geometry
{
public:
	// Declare the constructor.
	BoxGeometry()
	{
		Geometry::type = GT_BOX_GEOMETRY;
	};

	Vec3 		dimensions{ 1,1,1 };									// Dimensions of the box
};


// Defines a sphere geometry
class SphereGeometry : public Geometry
{
public:
	// Declare the constructor.
	SphereGeometry()
	{
		Geometry::type = GT_SPHERE_GEOMETRY;
	};

	float  		radius{ 1 };  										// The radius of the sphere
};


// Defines a capsule geometry
class CapsuleGeometry : public Geometry
{
public:
	// Declare the constructor.
	CapsuleGeometry()
	{
		Geometry::type = GT_CAPSULE_GEOMETRY;
	};

	float  		radius{ 1 };  										// The radius of the capsule
	float  		height{ 1 };  										// The height of the capsule
};


// Defines a cylinder geometry
class CylinderGeometry : public Geometry
{
public:
	// Declare the constructor.
	CylinderGeometry()
	{
		Geometry::type = GT_CYLINDER_GEOMETRY;
	};

	float  		radius{ 1 };  										// The radius of the cylinder
	float  		height{ 1 };  										// The height of the cylinder
};


// Defines a convex mesh geometry
class ConvexHullGeometry : public Geometry
{
public:
	// Declare the constructor.
	ConvexHullGeometry()
	{
		Geometry::type = GT_CONVEXHULL_GEOMETRY;
	};

	MeshScale  	scale;   										// The scale to apply to this convex mesh
	const char * convexMesh; 									// The name of the convex mesh asset
};


// Defines a triangle mesh geometry
class TriangleMeshGeometry : public Geometry
{
public:
	// Declare the constructor.
	TriangleMeshGeometry()
	{
		Geometry::type = GT_TRIANGLEMESH_GEOMETRY;
	};

	MeshScale  	scale;   										// The scale of the triangle mesh
	const char * triangleMesh;   								// The name of the triangle mesh asset
	bool 		doubleSided{ false }; 								// Whether or not this triangle mesh should be treated as double sided for collision detection
};


// Defines a plane equation geometry (position and orientation of the plane come from the geometry instance)
class PlaneGeometry : public Geometry
{
public:
	// Declare the constructor.
	PlaneGeometry()
	{
		Geometry::type = GT_PLANE_GEOMETRY;
	};

};


// Defines a single instance of a geometry
class GeometryInstance
{
public:

	// Declare the constructor.
	GeometryInstance() { }

	Geometry 	*geometry{ nullptr };								// The geometry associated with this instance
	const char * material;   									// Id of physical material associated with this propery
	Pose 		localPose;  											// The local pose for this geometry instance
	const char * collisionFilterSettings;  						// Describes collision filtering settings; what other types of objects this object will collide with
};


// Defines the common properties for a rigid body
class RigidBody : public Node
{
public:
	// Declare the constructor.
	RigidBody()
	{
		Node::type = NT_RIGID_BODY;
	};

	uint32_t 	geometryInstancesCount { 0 };
	const GeometryInstance* geometryInstances;   				// The set of geometries to instance with this actor
	Pose 		globalPose;   										// The global pose for this actor
};


// Defines a static rigid body
class RigidStatic : public RigidBody
{
public:
	// Declare the constructor.
	RigidStatic()
	{
		Node::type = NT_RIGID_STATIC;
	};

};


// Defines a dynamic rigid body
class RigidDynamic : public RigidBody
{
public:
	// Declare the constructor.
	RigidDynamic()
	{
		Node::type = NT_RIGID_DYNAMIC;
	};

	bool 		disableGravity;   									// Disables scene gravity for this actor
	Pose 		centerOfMassLocalPose;  								// Center of mass and local pose
	float  		mass;   											// Sets the mass of a dynamic actor.
	Vec3 		massSpaceInertiaTensor;   							// Sets the inertia tensor, using a parameter specified in mass space coordinates.
	Vec3 		linearVelocity;   									// Sets the linear velocity of the actor.
	Vec3 		angularVelocity;										// Sets the angular velocity of the actor.
	float  		linearDamping{ 0 }; 								// Sets the linear damping coefficient.
	float  		angularDamping{ 0.05f };  							// Sets the angular damping coefficient.
	float  		maxAngularVelocity{ 7 };  							// set the maximum angular velocity permitted for this actor.
	bool 		kinematic{ false };   								// If true this is a dynamic object; but currently kinematically controlled
};


// Defines the common properties for a joint
class Joint : public Node
{
public:
	// Declare the constructor.
	Joint()
	{
		Node::type = NT_JOINT;
	};

	const char * body0;											// Id of first rigid body joint is constrained to; if empty string; then constaint to the world
	const char * body1;											// Id of the second rigid body the joint is constrainted to
	Pose 		localpose0;   										// The parent relative pose; relative to body0
	Pose 		localpose1;   										// The parent relative pose; relative to body1
	bool 		collisionEnabled{ false };  							// 
};


// Defines two bodies, by id, that should not collide with each other
class BodyPairFilter
{
public:
	const char * bodyA;											// Id of first body
	const char * bodyB ; 										// Id of second body
};


// A collection of body pair filters
class BodyPairFilters : public Node
{
public:
	// Declare the constructor.
	BodyPairFilters()
	{
		Node::type = NT_BODY_PAIR_FILTERS;
	};

	uint32_t 	bodyPairsCount { 0 };
	const BodyPairFilter* bodyPairs; 							// Array of body pair filters
};


class InstanceCollection : public Node
{
public:
	// Declare the constructor.
	InstanceCollection()
	{
		Node::type = NT_INSTANCE_COLLECTION;
	};

	const char * collection; 									// Name of collection to instance
	Pose 		pose; 												// Pose to instance collection at
	Vec3 		scale;  												// Scale of instance
};


// A collection of nodes
class Collection : public Node
{
public:
	// Declare the constructor.
	Collection()
	{
		Node::type = NT_COLLECTION;
	};

	uint32_t 	nodesCount { 0 };
	const Node*	nodes;   										// Array of nodes in this collection
};


// A special type of 'collection' which is instantiated on startup
class Scene : public Collection
{
public:
	// Declare the constructor.
	Scene()
	{
		Node::type = NT_SCENE;
	};

	Vec3 		gravity{ 0.0f,-9.8f,0.0f };   						// Gravity
};


// The root node container
class PhysicsDOM
{
public:

	// Declare the constructor.
	PhysicsDOM() { }

	uint32_t 	collectionsCount { 0 };
	const Collection* collections;   							// The array of top level collections
	uint32_t 	scenesCount { 0 };
	const Scene* scenes; 										// The array of top level scenes; a scene is instantiated into the physics simulation
};



} // End of PHYSICS_DOM namespace

#endif // End of Scene
