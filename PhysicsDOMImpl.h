#ifndef PHYSICSDOM_IMPL_H
#define PHYSICSDOM_IMPL_H

// CreateDOM: Schema Generation tool written by John W. Ratcliff, 2017
// Warning:This source file was auto-generated by the CreateDOM tool. Do not try to edit this source file manually!
// The Google DOCs Schema Spreadsheet for this source came from: https://docs.google.com/spreadsheets/d/118I5kdu2XT-6wfCG044937xfEKDyX2oNg04G8Wqi6o0/edit?usp=sharing

#include "PhysicsDOM.h"
#include <string>
#include <vector>
#include <stdint.h>


namespace PHYSICS_DOM
{


// Defines an optional visual mesh binding to a physics node
class VisualBindingImpl: public VisualBinding
{
public:
	std::string	mVisualName; 									// Name of associated visual mesh
};


// Describes a key-value pair for custom properties on a node
class KeyValuePairImpl: public KeyValuePair
{
public:
	std::string	mKey;  											// They 'key' identifier; what this property is
	std::string	mValue;											// The value of this property; up to each the user to figure out how to interpret each property relative to the keyword
};

typedef std::vector< KeyValuePair > KeyValuePairVector; // Forward declare the 'KeyValuePair' vector

// A collection of key/value pair properties relative to a particular category
class AdditionalPropertiesImpl: public AdditionalProperties
{
public:
	std::string	mCategory;   									// The category this set of key/value pairs is associated with (example 'physx', 'mujoco', etc.
	KeyValuePairVector mKeyValuePairs;   						// The array of key/value pairs associated with this category
};

typedef std::vector< AdditionalProperties > AdditionalPropertiesVector; // Forward declare the 'AdditionalProperties' vector

// Base class that specifies a unique ID and an optional description name field for an object
class NodeImpl: public Node
{
public:

	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	NodeImpl(const NodeImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new NodeImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	NodeImpl& operator=(const NodeImpl& other)
	{
		if (this != &other )
		{
			mId = other.mId;
			mName = other.mName;
			mAdditionalProperties = other.mAdditionalProperties;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		id = mId.c_str(); // Assign the current string pointer.
		name = mName.c_str(); // Assign the current string pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	NodeImpl(NodeImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	NodeImpl& operator=(NodeImpl&& other)
	{
		if (this != &other )
		{
			mId = other.mId;
			mName = other.mName;
			mAdditionalProperties = other.mAdditionalProperties;
		}
		return *this;
	}

	std::string	mId; 											// Unique Id for this object
	std::string	mName;   										// Optional name for this object
	AdditionalPropertiesVector mAdditionalProperties;  			// An optional set of properties for this node; a set of key-value pairs for each application/engine specific category
};


// Defines the physical material properties of a surface
class PhysicsMaterialImpl: public PhysicsMaterial
{
public:
	// Declare the constructor.
	PhysicsMaterialImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~PhysicsMaterialImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	PhysicsMaterialImpl(const PhysicsMaterialImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new PhysicsMaterialImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	PhysicsMaterialImpl& operator=(const PhysicsMaterialImpl& other)
	{
		if (this != &other )
		{
			Node::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Node::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	PhysicsMaterialImpl(PhysicsMaterialImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	PhysicsMaterialImpl& operator=(PhysicsMaterialImpl&& other)
	{
		if (this != &other )
		{
			Node::operator=(std::move(other));
		}
		return *this;
	}

};

typedef std::vector< Vec3 > Vec3Vector; // Forward declare the 'Vec3' vector

// Describes the data for a convex hull
class ConvexHullImpl: public ConvexHull
{
public:
	// Declare the constructor.
	ConvexHullImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~ConvexHullImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	ConvexHullImpl(const ConvexHullImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new ConvexHullImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	ConvexHullImpl& operator=(const ConvexHullImpl& other)
	{
		if (this != &other )
		{
			Node::operator=(other);
			mPoints = other.mPoints;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Node::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	ConvexHullImpl(ConvexHullImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	ConvexHullImpl& operator=(ConvexHullImpl&& other)
	{
		if (this != &other )
		{
			Node::operator=(std::move(other));
			mPoints = other.mPoints;
		}
		return *this;
	}

	Vec3Vector   mPoints;  										// Array of data points describing the convex hull
};

typedef std::vector< uint32_t > U32Vector; // Forward declare the 'U32' vector
typedef std::vector< uint8_t > U8Vector; // Forward declare the 'U8' vector

// Describes the data for a triangle mesh
class TriangleMeshImpl: public TriangleMesh
{
public:
	// Declare the constructor.
	TriangleMeshImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~TriangleMeshImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	TriangleMeshImpl(const TriangleMeshImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new TriangleMeshImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	TriangleMeshImpl& operator=(const TriangleMeshImpl& other)
	{
		if (this != &other )
		{
			Node::operator=(other);
			mPoints = other.mPoints;
			mTriangles = other.mTriangles;
			mMaterialIndices = other.mMaterialIndices;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Node::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	TriangleMeshImpl(TriangleMeshImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	TriangleMeshImpl& operator=(TriangleMeshImpl&& other)
	{
		if (this != &other )
		{
			Node::operator=(std::move(other));
			mPoints = other.mPoints;
			mTriangles = other.mTriangles;
			mMaterialIndices = other.mMaterialIndices;
		}
		return *this;
	}

	Vec3Vector   mPoints;  										// Array of vertices for the triangle mesh
	U32Vector  	mTriangles;										// Array of triangle indices
	U8Vector 	mMaterialIndices;									// Optional per-triangle material index
};

typedef std::vector< uint16_t > U16Vector; // Forward declare the 'U16' vector

// The data for a heighfield; as 2d array of 32 bit samples; 16 bits for height, 16 bits for material indices, holes, and other metadata
class HeightFieldImpl: public HeightField
{
public:
	// Declare the constructor.
	HeightFieldImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~HeightFieldImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	HeightFieldImpl(const HeightFieldImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new HeightFieldImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	HeightFieldImpl& operator=(const HeightFieldImpl& other)
	{
		if (this != &other )
		{
			Node::operator=(other);
			mSamples = other.mSamples;
			mMetaData = other.mMetaData;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Node::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	HeightFieldImpl(HeightFieldImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	HeightFieldImpl& operator=(HeightFieldImpl&& other)
	{
		if (this != &other )
		{
			Node::operator=(std::move(other));
			mSamples = other.mSamples;
			mMetaData = other.mMetaData;
		}
		return *this;
	}

	U16Vector  	mSamples;  										// Heightfield sample data
	U16Vector  	mMetaData;   									// Optional meta data for each sample; determines per sample material, winding order, and whether or not to treat it as a hole
};


// Base class for all geometries
class GeometryImpl: public Geometry
{
public:

	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	GeometryImpl(const GeometryImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new GeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	GeometryImpl& operator=(const GeometryImpl& other)
	{
		if (this != &other )
		{
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	GeometryImpl(GeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	GeometryImpl& operator=(GeometryImpl&& other)
	{
		if (this != &other )
		{
		}
		return *this;
	}

};


// Defines a box geometry
class BoxGeometryImpl: public BoxGeometry
{
public:
	// Declare the constructor.
	BoxGeometryImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~BoxGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	BoxGeometryImpl(const BoxGeometryImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new BoxGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	BoxGeometryImpl& operator=(const BoxGeometryImpl& other)
	{
		if (this != &other )
		{
			Geometry::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Geometry::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	BoxGeometryImpl(BoxGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	BoxGeometryImpl& operator=(BoxGeometryImpl&& other)
	{
		if (this != &other )
		{
			Geometry::operator=(std::move(other));
		}
		return *this;
	}

};


// Defines a sphere geometry
class SphereGeometryImpl: public SphereGeometry
{
public:
	// Declare the constructor.
	SphereGeometryImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~SphereGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	SphereGeometryImpl(const SphereGeometryImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new SphereGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	SphereGeometryImpl& operator=(const SphereGeometryImpl& other)
	{
		if (this != &other )
		{
			Geometry::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Geometry::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	SphereGeometryImpl(SphereGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	SphereGeometryImpl& operator=(SphereGeometryImpl&& other)
	{
		if (this != &other )
		{
			Geometry::operator=(std::move(other));
		}
		return *this;
	}

};


// Defines a capsule geometry
class CapsuleGeometryImpl: public CapsuleGeometry
{
public:
	// Declare the constructor.
	CapsuleGeometryImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~CapsuleGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	CapsuleGeometryImpl(const CapsuleGeometryImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new CapsuleGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	CapsuleGeometryImpl& operator=(const CapsuleGeometryImpl& other)
	{
		if (this != &other )
		{
			Geometry::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Geometry::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	CapsuleGeometryImpl(CapsuleGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	CapsuleGeometryImpl& operator=(CapsuleGeometryImpl&& other)
	{
		if (this != &other )
		{
			Geometry::operator=(std::move(other));
		}
		return *this;
	}

};


// Defines a cylinder geometry
class CylinderGeometryImpl: public CylinderGeometry
{
public:
	// Declare the constructor.
	CylinderGeometryImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~CylinderGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	CylinderGeometryImpl(const CylinderGeometryImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new CylinderGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	CylinderGeometryImpl& operator=(const CylinderGeometryImpl& other)
	{
		if (this != &other )
		{
			Geometry::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Geometry::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	CylinderGeometryImpl(CylinderGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	CylinderGeometryImpl& operator=(CylinderGeometryImpl&& other)
	{
		if (this != &other )
		{
			Geometry::operator=(std::move(other));
		}
		return *this;
	}

};


// Defines a convex mesh geometry
class ConvexHullGeometryImpl: public ConvexHullGeometry
{
public:
	// Declare the constructor.
	ConvexHullGeometryImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~ConvexHullGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	ConvexHullGeometryImpl(const ConvexHullGeometryImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new ConvexHullGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	ConvexHullGeometryImpl& operator=(const ConvexHullGeometryImpl& other)
	{
		if (this != &other )
		{
			Geometry::operator=(other);
			mConvexMesh = other.mConvexMesh;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Geometry::initDOM();
		convexMesh = mConvexMesh.c_str(); // Assign the current string pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	ConvexHullGeometryImpl(ConvexHullGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	ConvexHullGeometryImpl& operator=(ConvexHullGeometryImpl&& other)
	{
		if (this != &other )
		{
			Geometry::operator=(std::move(other));
			mConvexMesh = other.mConvexMesh;
		}
		return *this;
	}

	std::string	mConvexMesh; 									// The name of the convex mesh asset
};


// Defines a triangle mesh geometry
class TriangleMeshGeometryImpl: public TriangleMeshGeometry
{
public:
	// Declare the constructor.
	TriangleMeshGeometryImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~TriangleMeshGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	TriangleMeshGeometryImpl(const TriangleMeshGeometryImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new TriangleMeshGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	TriangleMeshGeometryImpl& operator=(const TriangleMeshGeometryImpl& other)
	{
		if (this != &other )
		{
			Geometry::operator=(other);
			mTriangleMesh = other.mTriangleMesh;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Geometry::initDOM();
		triangleMesh = mTriangleMesh.c_str(); // Assign the current string pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	TriangleMeshGeometryImpl(TriangleMeshGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	TriangleMeshGeometryImpl& operator=(TriangleMeshGeometryImpl&& other)
	{
		if (this != &other )
		{
			Geometry::operator=(std::move(other));
			mTriangleMesh = other.mTriangleMesh;
		}
		return *this;
	}

	std::string	mTriangleMesh;   								// The name of the triangle mesh asset
};


// Defines a heightfield geometry
class HeightFieldGeometryImpl: public HeightFieldGeometry
{
public:
	// Declare the constructor.
	HeightFieldGeometryImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~HeightFieldGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	HeightFieldGeometryImpl(const HeightFieldGeometryImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new HeightFieldGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	HeightFieldGeometryImpl& operator=(const HeightFieldGeometryImpl& other)
	{
		if (this != &other )
		{
			Geometry::operator=(other);
			mHeightField = other.mHeightField;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Geometry::initDOM();
		heightField = mHeightField.c_str(); // Assign the current string pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	HeightFieldGeometryImpl(HeightFieldGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	HeightFieldGeometryImpl& operator=(HeightFieldGeometryImpl&& other)
	{
		if (this != &other )
		{
			Geometry::operator=(std::move(other));
			mHeightField = other.mHeightField;
		}
		return *this;
	}

	std::string	mHeightField;  									// The id of the heightfield data asset
};


// Defines a plane equation geometry (position and orientation of the plane come from the geometry instance)
class PlaneGeometryImpl: public PlaneGeometry
{
public:
	// Declare the constructor.
	PlaneGeometryImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~PlaneGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	PlaneGeometryImpl(const PlaneGeometryImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new PlaneGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	PlaneGeometryImpl& operator=(const PlaneGeometryImpl& other)
	{
		if (this != &other )
		{
			Geometry::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Geometry::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	PlaneGeometryImpl(PlaneGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	PlaneGeometryImpl& operator=(PlaneGeometryImpl&& other)
	{
		if (this != &other )
		{
			Geometry::operator=(std::move(other));
		}
		return *this;
	}

};

typedef std::vector< std::string > StringVector; // Forward declare the 'String' vector

// Defines a single instance of a geometry
class GeometryInstanceImpl: public GeometryInstance
{
public:

	// Declare the constructor.
	GeometryInstanceImpl() { }


	// Declare the virtual destructor; cleanup any pointers or arrays of pointers
	virtual ~GeometryInstanceImpl()
	{
		delete mGeometry; // Delete this object
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	GeometryInstanceImpl(const GeometryInstanceImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new GeometryInstanceImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	GeometryInstanceImpl& operator=(const GeometryInstanceImpl& other)
	{
		if (this != &other )
		{
			delete mGeometry; // delete any previous pointer.
			mGeometry = nullptr; // set the pointer to null.
			if ( other.mGeometry )
			{
				mGeometry = static_cast<GeometryImpl *>(other.mGeometry->clone()); // perform the deep copy and assignment here
			}
			mMaterials = other.mMaterials;
			mCollisionFilterSettings = other.mCollisionFilterSettings;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		materials = mMaterials.c_str(); // Assign the current string pointer.
		collisionFilterSettings = mCollisionFilterSettings.c_str(); // Assign the current string pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	GeometryInstanceImpl(GeometryInstanceImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	GeometryInstanceImpl& operator=(GeometryInstanceImpl&& other)
	{
		if (this != &other )
		{
			mGeometry = other.mGeometry;
			other.mGeometry = nullptr; // Set 'other' pointer to null since we have moved it
			mMaterials = other.mMaterials;
			mCollisionFilterSettings = other.mCollisionFilterSettings;
		}
		return *this;
	}

	GeometryImpl *mGeometry{ nullptr };							// The geometry associated with this instance
	StringVector mMaterials; 									// Id of physical material(s) associated with this geometry instance (usually one material; but for heightifields and triangle meshes can be more than one)
	std::string	mCollisionFilterSettings;  						// Describes collision filtering settings; what other types of objects this object will collide with
};

typedef std::vector< GeometryInstance *> GeometryInstanceVector; // Forward declare the 'GeometryInstance' vector for the implementation object pointers

// Defines the common properties for a rigid body
class RigidBodyImpl: public RigidBody
{
public:
	// Declare the constructor.
	RigidBodyImpl()
	{
	}


	// Declare the virtual destructor; cleanup any pointers or arrays of pointers
	virtual ~RigidBodyImpl()
	{
		for (auto &i:mGeometryInstances) delete i; // Delete all of the object pointers in this array
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	RigidBodyImpl(const RigidBodyImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new RigidBodyImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	RigidBodyImpl& operator=(const RigidBodyImpl& other)
	{
		if (this != &other )
		{
			Node::operator=(other);
			for (auto &i:mGeometryInstances) delete i; // Delete all of the object pointers in this array
			mGeometryInstances.clear(); // Clear the current array
			mGeometryInstances.reserve(other.mGeometryInstances.size()); // Reserve number of items for the new array
			for (auto &i:other.mGeometryInstances) mGeometryInstances.push_back( static_cast< GeometryInstanceImpl *>(i->clone())); // Deep copy object pointers into the array
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Node::initDOM();
		geometryInstances = mGeometryInstances; // Assign the current object pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	RigidBodyImpl(RigidBodyImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	RigidBodyImpl& operator=(RigidBodyImpl&& other)
	{
		if (this != &other )
		{
			Node::operator=(std::move(other));
			mGeometryInstances = other.mGeometryInstances;
			other.mGeometryInstances.clear(); // Clear the 'other' array now that we have moved it
		}
		return *this;
	}

	GeometryInstanceVector mGeometryInstances;   				// The set of geometries to instance with this actor
};


// Defines a static rigid body
class RigidStaticImpl: public RigidStatic
{
public:
	// Declare the constructor.
	RigidStaticImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~RigidStaticImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	RigidStaticImpl(const RigidStaticImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new RigidStaticImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	RigidStaticImpl& operator=(const RigidStaticImpl& other)
	{
		if (this != &other )
		{
			RigidBody::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		RigidBody::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	RigidStaticImpl(RigidStaticImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	RigidStaticImpl& operator=(RigidStaticImpl&& other)
	{
		if (this != &other )
		{
			RigidBody::operator=(std::move(other));
		}
		return *this;
	}

};


// Defines a dynamic rigid body
class RigidDynamicImpl: public RigidDynamic
{
public:
	// Declare the constructor.
	RigidDynamicImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~RigidDynamicImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	RigidDynamicImpl(const RigidDynamicImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new RigidDynamicImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	RigidDynamicImpl& operator=(const RigidDynamicImpl& other)
	{
		if (this != &other )
		{
			RigidBody::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		RigidBody::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	RigidDynamicImpl(RigidDynamicImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	RigidDynamicImpl& operator=(RigidDynamicImpl&& other)
	{
		if (this != &other )
		{
			RigidBody::operator=(std::move(other));
		}
		return *this;
	}

};


// Defines the common properties for a joint
class JointImpl: public Joint
{
public:
	// Declare the constructor.
	JointImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~JointImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	JointImpl(const JointImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new JointImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	JointImpl& operator=(const JointImpl& other)
	{
		if (this != &other )
		{
			Node::operator=(other);
			mBody0 = other.mBody0;
			mBody1 = other.mBody1;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Node::initDOM();
		body0 = mBody0.c_str(); // Assign the current string pointer.
		body1 = mBody1.c_str(); // Assign the current string pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	JointImpl(JointImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	JointImpl& operator=(JointImpl&& other)
	{
		if (this != &other )
		{
			Node::operator=(std::move(other));
			mBody0 = other.mBody0;
			mBody1 = other.mBody1;
		}
		return *this;
	}

	std::string	mBody0;											// Id of first rigid body joint is constrained to; if empty string; then constaint to the world
	std::string	mBody1;											// Id of the second rigid body the joint is constrainted to
};


// Defines the properties speciic to a fixed joint 
// Not all properties yet defined!
class FixedJointImpl: public FixedJoint
{
public:
	// Declare the constructor.
	FixedJointImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~FixedJointImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	FixedJointImpl(const FixedJointImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new FixedJointImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	FixedJointImpl& operator=(const FixedJointImpl& other)
	{
		if (this != &other )
		{
			Joint::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Joint::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	FixedJointImpl(FixedJointImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	FixedJointImpl& operator=(FixedJointImpl&& other)
	{
		if (this != &other )
		{
			Joint::operator=(std::move(other));
		}
		return *this;
	}

};


// Defines the properties speciic to a spherical joint 
// Not all properties yet defined!
class SphericalJointImpl: public SphericalJoint
{
public:
	// Declare the constructor.
	SphericalJointImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~SphericalJointImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	SphericalJointImpl(const SphericalJointImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new SphericalJointImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	SphericalJointImpl& operator=(const SphericalJointImpl& other)
	{
		if (this != &other )
		{
			Joint::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Joint::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	SphericalJointImpl(SphericalJointImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	SphericalJointImpl& operator=(SphericalJointImpl&& other)
	{
		if (this != &other )
		{
			Joint::operator=(std::move(other));
		}
		return *this;
	}

};


// Defines the properties speciic to a revolute joint 
// Not all properties yet defined!
class RevoluteJointImpl: public RevoluteJoint
{
public:
	// Declare the constructor.
	RevoluteJointImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~RevoluteJointImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	RevoluteJointImpl(const RevoluteJointImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new RevoluteJointImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	RevoluteJointImpl& operator=(const RevoluteJointImpl& other)
	{
		if (this != &other )
		{
			Joint::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Joint::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	RevoluteJointImpl(RevoluteJointImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	RevoluteJointImpl& operator=(RevoluteJointImpl&& other)
	{
		if (this != &other )
		{
			Joint::operator=(std::move(other));
		}
		return *this;
	}

};


// Defines the properties speciic to a prismatic joint 
// Not all properties yet defined!
class PrismaticJointImpl: public PrismaticJoint
{
public:
	// Declare the constructor.
	PrismaticJointImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~PrismaticJointImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	PrismaticJointImpl(const PrismaticJointImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new PrismaticJointImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	PrismaticJointImpl& operator=(const PrismaticJointImpl& other)
	{
		if (this != &other )
		{
			Joint::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Joint::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	PrismaticJointImpl(PrismaticJointImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	PrismaticJointImpl& operator=(PrismaticJointImpl&& other)
	{
		if (this != &other )
		{
			Joint::operator=(std::move(other));
		}
		return *this;
	}

};


// Defines the properties speciic to a distance joint 
// Not all properties yet defined!
class DistanceJointImpl: public DistanceJoint
{
public:
	// Declare the constructor.
	DistanceJointImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~DistanceJointImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	DistanceJointImpl(const DistanceJointImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new DistanceJointImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	DistanceJointImpl& operator=(const DistanceJointImpl& other)
	{
		if (this != &other )
		{
			Joint::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Joint::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	DistanceJointImpl(DistanceJointImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	DistanceJointImpl& operator=(DistanceJointImpl&& other)
	{
		if (this != &other )
		{
			Joint::operator=(std::move(other));
		}
		return *this;
	}

};


// Defines the properties speciic to a ball and socket joint 
// Not all properties yet defined!
class BallAndSocketJointImpl: public BallAndSocketJoint
{
public:
	// Declare the constructor.
	BallAndSocketJointImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~BallAndSocketJointImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	BallAndSocketJointImpl(const BallAndSocketJointImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new BallAndSocketJointImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	BallAndSocketJointImpl& operator=(const BallAndSocketJointImpl& other)
	{
		if (this != &other )
		{
			Joint::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Joint::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	BallAndSocketJointImpl(BallAndSocketJointImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	BallAndSocketJointImpl& operator=(BallAndSocketJointImpl&& other)
	{
		if (this != &other )
		{
			Joint::operator=(std::move(other));
		}
		return *this;
	}

};


// Defines the properties speciic to a six degree of freedom joint 
// Not all properties yet defined!
class D6JointImpl: public D6Joint
{
public:
	// Declare the constructor.
	D6JointImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~D6JointImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	D6JointImpl(const D6JointImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new D6JointImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	D6JointImpl& operator=(const D6JointImpl& other)
	{
		if (this != &other )
		{
			Joint::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Joint::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	D6JointImpl(D6JointImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	D6JointImpl& operator=(D6JointImpl&& other)
	{
		if (this != &other )
		{
			Joint::operator=(std::move(other));
		}
		return *this;
	}

};


// Defines two bodies, by id, that should not collide with each other
class BodyPairFilterImpl: public BodyPairFilter
{
public:
	std::string	mBodyA;											// Id of first body
	std::string	mBodyB ; 										// Id of second body
};

typedef std::vector< BodyPairFilter > BodyPairFilterVector; // Forward declare the 'BodyPairFilter' vector

// A collection of body pair filters
class BodyPairFiltersImpl: public BodyPairFilters
{
public:
	// Declare the constructor.
	BodyPairFiltersImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~BodyPairFiltersImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	BodyPairFiltersImpl(const BodyPairFiltersImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new BodyPairFiltersImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	BodyPairFiltersImpl& operator=(const BodyPairFiltersImpl& other)
	{
		if (this != &other )
		{
			Node::operator=(other);
			mBodyPairs = other.mBodyPairs;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Node::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	BodyPairFiltersImpl(BodyPairFiltersImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	BodyPairFiltersImpl& operator=(BodyPairFiltersImpl&& other)
	{
		if (this != &other )
		{
			Node::operator=(std::move(other));
			mBodyPairs = other.mBodyPairs;
		}
		return *this;
	}

	BodyPairFilterVector mBodyPairs; 							// Array of body pair filters
};


class InstanceCollectionImpl: public InstanceCollection
{
public:
	// Declare the constructor.
	InstanceCollectionImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~InstanceCollectionImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	InstanceCollectionImpl(const InstanceCollectionImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new InstanceCollectionImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	InstanceCollectionImpl& operator=(const InstanceCollectionImpl& other)
	{
		if (this != &other )
		{
			Node::operator=(other);
			mCollection = other.mCollection;
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Node::initDOM();
		collection = mCollection.c_str(); // Assign the current string pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	InstanceCollectionImpl(InstanceCollectionImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	InstanceCollectionImpl& operator=(InstanceCollectionImpl&& other)
	{
		if (this != &other )
		{
			Node::operator=(std::move(other));
			mCollection = other.mCollection;
		}
		return *this;
	}

	std::string	mCollection; 									// Name of collection to instance
};

typedef std::vector< Node *> NodeVector; // Forward declare the 'Node' vector for the implementation object pointers

// A collection of nodes
class CollectionImpl: public Collection
{
public:
	// Declare the constructor.
	CollectionImpl()
	{
	}


	// Declare the virtual destructor; cleanup any pointers or arrays of pointers
	virtual ~CollectionImpl()
	{
		for (auto &i:mNodes) delete i; // Delete all of the object pointers in this array
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	CollectionImpl(const CollectionImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new CollectionImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	CollectionImpl& operator=(const CollectionImpl& other)
	{
		if (this != &other )
		{
			Node::operator=(other);
			for (auto &i:mNodes) delete i; // Delete all of the object pointers in this array
			mNodes.clear(); // Clear the current array
			mNodes.reserve(other.mNodes.size()); // Reserve number of items for the new array
			for (auto &i:other.mNodes) mNodes.push_back( static_cast< NodeImpl *>(i->clone())); // Deep copy object pointers into the array
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Node::initDOM();
		nodes = mNodes; // Assign the current object pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	CollectionImpl(CollectionImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	CollectionImpl& operator=(CollectionImpl&& other)
	{
		if (this != &other )
		{
			Node::operator=(std::move(other));
			mNodes = other.mNodes;
			other.mNodes.clear(); // Clear the 'other' array now that we have moved it
		}
		return *this;
	}

	NodeVector   mNodes; 										// Array of nodes in this collection
};


// A special type of 'collection' which is instantiated on startup
class SceneImpl: public Scene
{
public:
	// Declare the constructor.
	SceneImpl()
	{
	}


	// Declare the virtual destructor.
	virtual ~SceneImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	SceneImpl(const SceneImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new SceneImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	SceneImpl& operator=(const SceneImpl& other)
	{
		if (this != &other )
		{
			Collection::operator=(other);
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		Collection::initDOM();
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	SceneImpl(SceneImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	SceneImpl& operator=(SceneImpl&& other)
	{
		if (this != &other )
		{
			Collection::operator=(std::move(other));
		}
		return *this;
	}

};

typedef std::vector< Collection *> CollectionVector; // Forward declare the 'Collection' vector for the implementation object pointers
typedef std::vector< Scene *> SceneVector; // Forward declare the 'Scene' vector for the implementation object pointers

// The root node container
class PhysicsDOMImpl: public PhysicsDOM
{
public:

	// Declare the constructor.
	PhysicsDOMImpl() { }


	// Declare the virtual destructor; cleanup any pointers or arrays of pointers
	virtual ~PhysicsDOMImpl()
	{
		for (auto &i:mCollections) delete i; // Delete all of the object pointers in this array
		for (auto &i:mScenes) delete i; // Delete all of the object pointers in this array
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	PhysicsDOMImpl(const PhysicsDOMImpl &other)
	{
		*this = other;
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new PhysicsDOMImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	PhysicsDOMImpl& operator=(const PhysicsDOMImpl& other)
	{
		if (this != &other )
		{
			for (auto &i:mCollections) delete i; // Delete all of the object pointers in this array
			mCollections.clear(); // Clear the current array
			mCollections.reserve(other.mCollections.size()); // Reserve number of items for the new array
			for (auto &i:other.mCollections) mCollections.push_back( static_cast< CollectionImpl *>(i->clone())); // Deep copy object pointers into the array
			for (auto &i:mScenes) delete i; // Delete all of the object pointers in this array
			mScenes.clear(); // Clear the current array
			mScenes.reserve(other.mScenes.size()); // Reserve number of items for the new array
			for (auto &i:other.mScenes) mScenes.push_back( static_cast< SceneImpl *>(i->clone())); // Deep copy object pointers into the array
		}
		return *this;
	}

	// Declare and implement the initDOM method
	void initDOM(void)
	{
		collections = mCollections; // Assign the current object pointer.
		scenes = mScenes; // Assign the current object pointer.
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	PhysicsDOMImpl(PhysicsDOMImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	PhysicsDOMImpl& operator=(PhysicsDOMImpl&& other)
	{
		if (this != &other )
		{
			mCollections = other.mCollections;
			other.mCollections.clear(); // Clear the 'other' array now that we have moved it
			mScenes = other.mScenes;
			other.mScenes.clear(); // Clear the 'other' array now that we have moved it
		}
		return *this;
	}

	CollectionVector mCollections;   							// The array of top level collections
	SceneVector	mScenes; 										// The array of top level scenes; a scene is instantiated into the physics simulation
};



} // End of PHYSICS_DOM namespace

#endif // End of Scene
