// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PhysicsDOM.proto

#ifndef PROTOBUF_PhysicsDOM_2eproto__INCLUDED
#define PROTOBUF_PhysicsDOM_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace CreateDOM {
class AdditionalProperties;
class AdditionalPropertiesDefaultTypeInternal;
extern AdditionalPropertiesDefaultTypeInternal _AdditionalProperties_default_instance_;
class BallAndSocketJoint;
class BallAndSocketJointDefaultTypeInternal;
extern BallAndSocketJointDefaultTypeInternal _BallAndSocketJoint_default_instance_;
class BodyPairFilter;
class BodyPairFilterDefaultTypeInternal;
extern BodyPairFilterDefaultTypeInternal _BodyPairFilter_default_instance_;
class BodyPairFilters;
class BodyPairFiltersDefaultTypeInternal;
extern BodyPairFiltersDefaultTypeInternal _BodyPairFilters_default_instance_;
class Bounds3;
class Bounds3DefaultTypeInternal;
extern Bounds3DefaultTypeInternal _Bounds3_default_instance_;
class BoxGeometry;
class BoxGeometryDefaultTypeInternal;
extern BoxGeometryDefaultTypeInternal _BoxGeometry_default_instance_;
class CapsuleGeometry;
class CapsuleGeometryDefaultTypeInternal;
extern CapsuleGeometryDefaultTypeInternal _CapsuleGeometry_default_instance_;
class Collection;
class CollectionDefaultTypeInternal;
extern CollectionDefaultTypeInternal _Collection_default_instance_;
class ConvexHull;
class ConvexHullDefaultTypeInternal;
extern ConvexHullDefaultTypeInternal _ConvexHull_default_instance_;
class ConvexHullGeometry;
class ConvexHullGeometryDefaultTypeInternal;
extern ConvexHullGeometryDefaultTypeInternal _ConvexHullGeometry_default_instance_;
class CylinderGeometry;
class CylinderGeometryDefaultTypeInternal;
extern CylinderGeometryDefaultTypeInternal _CylinderGeometry_default_instance_;
class D6Joint;
class D6JointDefaultTypeInternal;
extern D6JointDefaultTypeInternal _D6Joint_default_instance_;
class DistanceJoint;
class DistanceJointDefaultTypeInternal;
extern DistanceJointDefaultTypeInternal _DistanceJoint_default_instance_;
class FixedJoint;
class FixedJointDefaultTypeInternal;
extern FixedJointDefaultTypeInternal _FixedJoint_default_instance_;
class Geometry;
class GeometryDefaultTypeInternal;
extern GeometryDefaultTypeInternal _Geometry_default_instance_;
class GeometryInstance;
class GeometryInstanceDefaultTypeInternal;
extern GeometryInstanceDefaultTypeInternal _GeometryInstance_default_instance_;
class HeightField;
class HeightFieldDefaultTypeInternal;
extern HeightFieldDefaultTypeInternal _HeightField_default_instance_;
class HeightFieldGeometry;
class HeightFieldGeometryDefaultTypeInternal;
extern HeightFieldGeometryDefaultTypeInternal _HeightFieldGeometry_default_instance_;
class HingeJoint;
class HingeJointDefaultTypeInternal;
extern HingeJointDefaultTypeInternal _HingeJoint_default_instance_;
class InstanceCollection;
class InstanceCollectionDefaultTypeInternal;
extern InstanceCollectionDefaultTypeInternal _InstanceCollection_default_instance_;
class Joint;
class JointDefaultTypeInternal;
extern JointDefaultTypeInternal _Joint_default_instance_;
class KeyValuePair;
class KeyValuePairDefaultTypeInternal;
extern KeyValuePairDefaultTypeInternal _KeyValuePair_default_instance_;
class MeshScale;
class MeshScaleDefaultTypeInternal;
extern MeshScaleDefaultTypeInternal _MeshScale_default_instance_;
class Node;
class NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class PhysicsDOM;
class PhysicsDOMDefaultTypeInternal;
extern PhysicsDOMDefaultTypeInternal _PhysicsDOM_default_instance_;
class PhysicsMaterial;
class PhysicsMaterialDefaultTypeInternal;
extern PhysicsMaterialDefaultTypeInternal _PhysicsMaterial_default_instance_;
class Plane;
class PlaneDefaultTypeInternal;
extern PlaneDefaultTypeInternal _Plane_default_instance_;
class PlaneGeometry;
class PlaneGeometryDefaultTypeInternal;
extern PlaneGeometryDefaultTypeInternal _PlaneGeometry_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class PrismaticJoint;
class PrismaticJointDefaultTypeInternal;
extern PrismaticJointDefaultTypeInternal _PrismaticJoint_default_instance_;
class Quat;
class QuatDefaultTypeInternal;
extern QuatDefaultTypeInternal _Quat_default_instance_;
class RigidBody;
class RigidBodyDefaultTypeInternal;
extern RigidBodyDefaultTypeInternal _RigidBody_default_instance_;
class RigidDynamic;
class RigidDynamicDefaultTypeInternal;
extern RigidDynamicDefaultTypeInternal _RigidDynamic_default_instance_;
class RigidStatic;
class RigidStaticDefaultTypeInternal;
extern RigidStaticDefaultTypeInternal _RigidStatic_default_instance_;
class Scene;
class SceneDefaultTypeInternal;
extern SceneDefaultTypeInternal _Scene_default_instance_;
class SphereGeometry;
class SphereGeometryDefaultTypeInternal;
extern SphereGeometryDefaultTypeInternal _SphereGeometry_default_instance_;
class SphericalJoint;
class SphericalJointDefaultTypeInternal;
extern SphericalJointDefaultTypeInternal _SphericalJoint_default_instance_;
class TriangleMesh;
class TriangleMeshDefaultTypeInternal;
extern TriangleMeshDefaultTypeInternal _TriangleMesh_default_instance_;
class TriangleMeshGeometry;
class TriangleMeshGeometryDefaultTypeInternal;
extern TriangleMeshGeometryDefaultTypeInternal _TriangleMeshGeometry_default_instance_;
class Vec3;
class Vec3DefaultTypeInternal;
extern Vec3DefaultTypeInternal _Vec3_default_instance_;
class VisualBinding;
class VisualBindingDefaultTypeInternal;
extern VisualBindingDefaultTypeInternal _VisualBinding_default_instance_;
}  // namespace CreateDOM

namespace CreateDOM {

namespace protobuf_PhysicsDOM_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_PhysicsDOM_2eproto

enum NodeType {
  NT_NODE = 0,
  NT_PHYSICS_MATERIAL = 1,
  NT_GEOMETRY_INSTANCE = 2,
  NT_TRIANGLEMESH = 3,
  NT_CONVEXHULL = 4,
  NT_HEIGHTFIELD = 5,
  NT_RIGID_BODY = 6,
  NT_RIGID_STATIC = 7,
  NT_RIGID_DYNAMIC = 8,
  NT_BODY_PAIR_FILTERS = 9,
  NT_JOINT = 10,
  NT_FIXED_JOINT = 11,
  NT_SPHERICAL_JOINT = 12,
  NT_HINGE_JOINT = 13,
  NT_PRISMATIC_JOINT = 14,
  NT_DISTANCE_JOINT = 15,
  NT_BALL_AND_SOCKET_JOINT = 16,
  NT_D6_JOINT = 17,
  NT_INSTANCE_COLLECTION = 18,
  NT_COLLECTION = 19,
  NT_SCENE = 20,
  NodeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NodeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NodeType_IsValid(int value);
const NodeType NodeType_MIN = NT_NODE;
const NodeType NodeType_MAX = NT_SCENE;
const int NodeType_ARRAYSIZE = NodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeType_descriptor();
inline const ::std::string& NodeType_Name(NodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeType_descriptor(), value);
}
inline bool NodeType_Parse(
    const ::std::string& name, NodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeType>(
    NodeType_descriptor(), name, value);
}
enum GeometryType {
  GT_BOX_GEOMETRY = 0,
  GT_SPHERE_GEOMETRY = 1,
  GT_CAPSULE_GEOMETRY = 2,
  GT_PLANE_GEOMETRY = 3,
  GT_CYLINDER_GEOMETRY = 4,
  GT_CONVEXHULL_GEOMETRY = 5,
  GT_TRIANGLEMESH_GEOMETRY = 6,
  GT_HEIGHTFIELD_GEOMETRY = 7,
  GeometryType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GeometryType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GeometryType_IsValid(int value);
const GeometryType GeometryType_MIN = GT_BOX_GEOMETRY;
const GeometryType GeometryType_MAX = GT_HEIGHTFIELD_GEOMETRY;
const int GeometryType_ARRAYSIZE = GeometryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GeometryType_descriptor();
inline const ::std::string& GeometryType_Name(GeometryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GeometryType_descriptor(), value);
}
inline bool GeometryType_Parse(
    const ::std::string& name, GeometryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GeometryType>(
    GeometryType_descriptor(), name, value);
}
// ===================================================================

class Vec3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.Vec3) */ {
 public:
  Vec3();
  virtual ~Vec3();

  Vec3(const Vec3& from);

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vec3(Vec3&& from) noexcept
    : Vec3() {
    *this = ::std::move(from);
  }

  inline Vec3& operator=(Vec3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec3& default_instance();

  static inline const Vec3* internal_default_instance() {
    return reinterpret_cast<const Vec3*>(
               &_Vec3_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Vec3* other);
  friend void swap(Vec3& a, Vec3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vec3* New() const PROTOBUF_FINAL { return New(NULL); }

  Vec3* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vec3& from);
  void MergeFrom(const Vec3& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vec3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:CreateDOM.Vec3)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Quat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.Quat) */ {
 public:
  Quat();
  virtual ~Quat();

  Quat(const Quat& from);

  inline Quat& operator=(const Quat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quat(Quat&& from) noexcept
    : Quat() {
    *this = ::std::move(from);
  }

  inline Quat& operator=(Quat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Quat& default_instance();

  static inline const Quat* internal_default_instance() {
    return reinterpret_cast<const Quat*>(
               &_Quat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Quat* other);
  friend void swap(Quat& a, Quat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quat* New() const PROTOBUF_FINAL { return New(NULL); }

  Quat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Quat& from);
  void MergeFrom(const Quat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Quat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // float w = 4;
  void clear_w();
  static const int kWFieldNumber = 4;
  float w() const;
  void set_w(float value);

  // @@protoc_insertion_point(class_scope:CreateDOM.Quat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  float w_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Plane : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.Plane) */ {
 public:
  Plane();
  virtual ~Plane();

  Plane(const Plane& from);

  inline Plane& operator=(const Plane& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Plane(Plane&& from) noexcept
    : Plane() {
    *this = ::std::move(from);
  }

  inline Plane& operator=(Plane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Plane& default_instance();

  static inline const Plane* internal_default_instance() {
    return reinterpret_cast<const Plane*>(
               &_Plane_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Plane* other);
  friend void swap(Plane& a, Plane& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Plane* New() const PROTOBUF_FINAL { return New(NULL); }

  Plane* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Plane& from);
  void MergeFrom(const Plane& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Plane* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CreateDOM.Vec3 n = 1;
  bool has_n() const;
  void clear_n();
  static const int kNFieldNumber = 1;
  const ::CreateDOM::Vec3& n() const;
  ::CreateDOM::Vec3* mutable_n();
  ::CreateDOM::Vec3* release_n();
  void set_allocated_n(::CreateDOM::Vec3* n);

  // float d = 2;
  void clear_d();
  static const int kDFieldNumber = 2;
  float d() const;
  void set_d(float value);

  // @@protoc_insertion_point(class_scope:CreateDOM.Plane)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::CreateDOM::Vec3* n_;
  float d_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.Pose) */ {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(Pose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Pose* other);
  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pose* New() const PROTOBUF_FINAL { return New(NULL); }

  Pose* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CreateDOM.Quat q = 1;
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 1;
  const ::CreateDOM::Quat& q() const;
  ::CreateDOM::Quat* mutable_q();
  ::CreateDOM::Quat* release_q();
  void set_allocated_q(::CreateDOM::Quat* q);

  // .CreateDOM.Vec3 p = 2;
  bool has_p() const;
  void clear_p();
  static const int kPFieldNumber = 2;
  const ::CreateDOM::Vec3& p() const;
  ::CreateDOM::Vec3* mutable_p();
  ::CreateDOM::Vec3* release_p();
  void set_allocated_p(::CreateDOM::Vec3* p);

  // @@protoc_insertion_point(class_scope:CreateDOM.Pose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::CreateDOM::Quat* q_;
  ::CreateDOM::Vec3* p_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Bounds3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.Bounds3) */ {
 public:
  Bounds3();
  virtual ~Bounds3();

  Bounds3(const Bounds3& from);

  inline Bounds3& operator=(const Bounds3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Bounds3(Bounds3&& from) noexcept
    : Bounds3() {
    *this = ::std::move(from);
  }

  inline Bounds3& operator=(Bounds3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Bounds3& default_instance();

  static inline const Bounds3* internal_default_instance() {
    return reinterpret_cast<const Bounds3*>(
               &_Bounds3_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Bounds3* other);
  friend void swap(Bounds3& a, Bounds3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Bounds3* New() const PROTOBUF_FINAL { return New(NULL); }

  Bounds3* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Bounds3& from);
  void MergeFrom(const Bounds3& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Bounds3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CreateDOM.Vec3 bmin = 1;
  bool has_bmin() const;
  void clear_bmin();
  static const int kBminFieldNumber = 1;
  const ::CreateDOM::Vec3& bmin() const;
  ::CreateDOM::Vec3* mutable_bmin();
  ::CreateDOM::Vec3* release_bmin();
  void set_allocated_bmin(::CreateDOM::Vec3* bmin);

  // .CreateDOM.Vec3 bmax = 2;
  bool has_bmax() const;
  void clear_bmax();
  static const int kBmaxFieldNumber = 2;
  const ::CreateDOM::Vec3& bmax() const;
  ::CreateDOM::Vec3* mutable_bmax();
  ::CreateDOM::Vec3* release_bmax();
  void set_allocated_bmax(::CreateDOM::Vec3* bmax);

  // @@protoc_insertion_point(class_scope:CreateDOM.Bounds3)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::CreateDOM::Vec3* bmin_;
  ::CreateDOM::Vec3* bmax_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VisualBinding : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.VisualBinding) */ {
 public:
  VisualBinding();
  virtual ~VisualBinding();

  VisualBinding(const VisualBinding& from);

  inline VisualBinding& operator=(const VisualBinding& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VisualBinding(VisualBinding&& from) noexcept
    : VisualBinding() {
    *this = ::std::move(from);
  }

  inline VisualBinding& operator=(VisualBinding&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VisualBinding& default_instance();

  static inline const VisualBinding* internal_default_instance() {
    return reinterpret_cast<const VisualBinding*>(
               &_VisualBinding_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(VisualBinding* other);
  friend void swap(VisualBinding& a, VisualBinding& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VisualBinding* New() const PROTOBUF_FINAL { return New(NULL); }

  VisualBinding* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VisualBinding& from);
  void MergeFrom(const VisualBinding& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VisualBinding* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string visualName = 1;
  void clear_visualname();
  static const int kVisualNameFieldNumber = 1;
  const ::std::string& visualname() const;
  void set_visualname(const ::std::string& value);
  #if LANG_CXX11
  void set_visualname(::std::string&& value);
  #endif
  void set_visualname(const char* value);
  void set_visualname(const char* value, size_t size);
  ::std::string* mutable_visualname();
  ::std::string* release_visualname();
  void set_allocated_visualname(::std::string* visualname);

  // .CreateDOM.Pose localPose = 2;
  bool has_localpose() const;
  void clear_localpose();
  static const int kLocalPoseFieldNumber = 2;
  const ::CreateDOM::Pose& localpose() const;
  ::CreateDOM::Pose* mutable_localpose();
  ::CreateDOM::Pose* release_localpose();
  void set_allocated_localpose(::CreateDOM::Pose* localpose);

  // .CreateDOM.Vec3 localScale = 3;
  bool has_localscale() const;
  void clear_localscale();
  static const int kLocalScaleFieldNumber = 3;
  const ::CreateDOM::Vec3& localscale() const;
  ::CreateDOM::Vec3* mutable_localscale();
  ::CreateDOM::Vec3* release_localscale();
  void set_allocated_localscale(::CreateDOM::Vec3* localscale);

  // @@protoc_insertion_point(class_scope:CreateDOM.VisualBinding)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr visualname_;
  ::CreateDOM::Pose* localpose_;
  ::CreateDOM::Vec3* localscale_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyValuePair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.KeyValuePair) */ {
 public:
  KeyValuePair();
  virtual ~KeyValuePair();

  KeyValuePair(const KeyValuePair& from);

  inline KeyValuePair& operator=(const KeyValuePair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyValuePair(KeyValuePair&& from) noexcept
    : KeyValuePair() {
    *this = ::std::move(from);
  }

  inline KeyValuePair& operator=(KeyValuePair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValuePair& default_instance();

  static inline const KeyValuePair* internal_default_instance() {
    return reinterpret_cast<const KeyValuePair*>(
               &_KeyValuePair_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(KeyValuePair* other);
  friend void swap(KeyValuePair& a, KeyValuePair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyValuePair* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyValuePair* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyValuePair& from);
  void MergeFrom(const KeyValuePair& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyValuePair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:CreateDOM.KeyValuePair)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdditionalProperties : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.AdditionalProperties) */ {
 public:
  AdditionalProperties();
  virtual ~AdditionalProperties();

  AdditionalProperties(const AdditionalProperties& from);

  inline AdditionalProperties& operator=(const AdditionalProperties& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdditionalProperties(AdditionalProperties&& from) noexcept
    : AdditionalProperties() {
    *this = ::std::move(from);
  }

  inline AdditionalProperties& operator=(AdditionalProperties&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AdditionalProperties& default_instance();

  static inline const AdditionalProperties* internal_default_instance() {
    return reinterpret_cast<const AdditionalProperties*>(
               &_AdditionalProperties_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(AdditionalProperties* other);
  friend void swap(AdditionalProperties& a, AdditionalProperties& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdditionalProperties* New() const PROTOBUF_FINAL { return New(NULL); }

  AdditionalProperties* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AdditionalProperties& from);
  void MergeFrom(const AdditionalProperties& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AdditionalProperties* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CreateDOM.KeyValuePair keyValuePairs = 2;
  int keyvaluepairs_size() const;
  void clear_keyvaluepairs();
  static const int kKeyValuePairsFieldNumber = 2;
  const ::CreateDOM::KeyValuePair& keyvaluepairs(int index) const;
  ::CreateDOM::KeyValuePair* mutable_keyvaluepairs(int index);
  ::CreateDOM::KeyValuePair* add_keyvaluepairs();
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::KeyValuePair >*
      mutable_keyvaluepairs();
  const ::google::protobuf::RepeatedPtrField< ::CreateDOM::KeyValuePair >&
      keyvaluepairs() const;

  // string category = 1;
  void clear_category();
  static const int kCategoryFieldNumber = 1;
  const ::std::string& category() const;
  void set_category(const ::std::string& value);
  #if LANG_CXX11
  void set_category(::std::string&& value);
  #endif
  void set_category(const char* value);
  void set_category(const char* value, size_t size);
  ::std::string* mutable_category();
  ::std::string* release_category();
  void set_allocated_category(::std::string* category);

  // @@protoc_insertion_point(class_scope:CreateDOM.AdditionalProperties)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::KeyValuePair > keyvaluepairs_;
  ::google::protobuf::internal::ArenaStringPtr category_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.Node) */ {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  enum SubtypeCase {
    kPhysicsMaterial = 6,
    kConvexHull = 7,
    kTriangleMesh = 8,
    kHeightField = 9,
    kRigidBody = 10,
    kJoint = 11,
    kBodyPairFilters = 12,
    kInstanceCollection = 13,
    kCollection = 14,
    kScene = 15,
    SUBTYPE_NOT_SET = 0,
  };

  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Node* other);
  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node* New() const PROTOBUF_FINAL { return New(NULL); }

  Node* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CreateDOM.AdditionalProperties additionalProperties = 5;
  int additionalproperties_size() const;
  void clear_additionalproperties();
  static const int kAdditionalPropertiesFieldNumber = 5;
  const ::CreateDOM::AdditionalProperties& additionalproperties(int index) const;
  ::CreateDOM::AdditionalProperties* mutable_additionalproperties(int index);
  ::CreateDOM::AdditionalProperties* add_additionalproperties();
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::AdditionalProperties >*
      mutable_additionalproperties();
  const ::google::protobuf::RepeatedPtrField< ::CreateDOM::AdditionalProperties >&
      additionalproperties() const;

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .CreateDOM.VisualBinding visual = 4;
  bool has_visual() const;
  void clear_visual();
  static const int kVisualFieldNumber = 4;
  const ::CreateDOM::VisualBinding& visual() const;
  ::CreateDOM::VisualBinding* mutable_visual();
  ::CreateDOM::VisualBinding* release_visual();
  void set_allocated_visual(::CreateDOM::VisualBinding* visual);

  // .CreateDOM.NodeType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::CreateDOM::NodeType type() const;
  void set_type(::CreateDOM::NodeType value);

  // .CreateDOM.PhysicsMaterial physicsMaterial = 6;
  bool has_physicsmaterial() const;
  void clear_physicsmaterial();
  static const int kPhysicsMaterialFieldNumber = 6;
  const ::CreateDOM::PhysicsMaterial& physicsmaterial() const;
  ::CreateDOM::PhysicsMaterial* mutable_physicsmaterial();
  ::CreateDOM::PhysicsMaterial* release_physicsmaterial();
  void set_allocated_physicsmaterial(::CreateDOM::PhysicsMaterial* physicsmaterial);

  // .CreateDOM.ConvexHull convexHull = 7;
  bool has_convexhull() const;
  void clear_convexhull();
  static const int kConvexHullFieldNumber = 7;
  const ::CreateDOM::ConvexHull& convexhull() const;
  ::CreateDOM::ConvexHull* mutable_convexhull();
  ::CreateDOM::ConvexHull* release_convexhull();
  void set_allocated_convexhull(::CreateDOM::ConvexHull* convexhull);

  // .CreateDOM.TriangleMesh triangleMesh = 8;
  bool has_trianglemesh() const;
  void clear_trianglemesh();
  static const int kTriangleMeshFieldNumber = 8;
  const ::CreateDOM::TriangleMesh& trianglemesh() const;
  ::CreateDOM::TriangleMesh* mutable_trianglemesh();
  ::CreateDOM::TriangleMesh* release_trianglemesh();
  void set_allocated_trianglemesh(::CreateDOM::TriangleMesh* trianglemesh);

  // .CreateDOM.HeightField heightField = 9;
  bool has_heightfield() const;
  void clear_heightfield();
  static const int kHeightFieldFieldNumber = 9;
  const ::CreateDOM::HeightField& heightfield() const;
  ::CreateDOM::HeightField* mutable_heightfield();
  ::CreateDOM::HeightField* release_heightfield();
  void set_allocated_heightfield(::CreateDOM::HeightField* heightfield);

  // .CreateDOM.RigidBody rigidBody = 10;
  bool has_rigidbody() const;
  void clear_rigidbody();
  static const int kRigidBodyFieldNumber = 10;
  const ::CreateDOM::RigidBody& rigidbody() const;
  ::CreateDOM::RigidBody* mutable_rigidbody();
  ::CreateDOM::RigidBody* release_rigidbody();
  void set_allocated_rigidbody(::CreateDOM::RigidBody* rigidbody);

  // .CreateDOM.Joint joint = 11;
  bool has_joint() const;
  void clear_joint();
  static const int kJointFieldNumber = 11;
  const ::CreateDOM::Joint& joint() const;
  ::CreateDOM::Joint* mutable_joint();
  ::CreateDOM::Joint* release_joint();
  void set_allocated_joint(::CreateDOM::Joint* joint);

  // .CreateDOM.BodyPairFilters bodyPairFilters = 12;
  bool has_bodypairfilters() const;
  void clear_bodypairfilters();
  static const int kBodyPairFiltersFieldNumber = 12;
  const ::CreateDOM::BodyPairFilters& bodypairfilters() const;
  ::CreateDOM::BodyPairFilters* mutable_bodypairfilters();
  ::CreateDOM::BodyPairFilters* release_bodypairfilters();
  void set_allocated_bodypairfilters(::CreateDOM::BodyPairFilters* bodypairfilters);

  // .CreateDOM.InstanceCollection instanceCollection = 13;
  bool has_instancecollection() const;
  void clear_instancecollection();
  static const int kInstanceCollectionFieldNumber = 13;
  const ::CreateDOM::InstanceCollection& instancecollection() const;
  ::CreateDOM::InstanceCollection* mutable_instancecollection();
  ::CreateDOM::InstanceCollection* release_instancecollection();
  void set_allocated_instancecollection(::CreateDOM::InstanceCollection* instancecollection);

  // .CreateDOM.Collection collection = 14;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 14;
  const ::CreateDOM::Collection& collection() const;
  ::CreateDOM::Collection* mutable_collection();
  ::CreateDOM::Collection* release_collection();
  void set_allocated_collection(::CreateDOM::Collection* collection);

  // .CreateDOM.Scene scene = 15;
  bool has_scene() const;
  void clear_scene();
  static const int kSceneFieldNumber = 15;
  const ::CreateDOM::Scene& scene() const;
  ::CreateDOM::Scene* mutable_scene();
  ::CreateDOM::Scene* release_scene();
  void set_allocated_scene(::CreateDOM::Scene* scene);

  SubtypeCase subtype_case() const;
  // @@protoc_insertion_point(class_scope:CreateDOM.Node)
 private:
  void set_has_physicsmaterial();
  void set_has_convexhull();
  void set_has_trianglemesh();
  void set_has_heightfield();
  void set_has_rigidbody();
  void set_has_joint();
  void set_has_bodypairfilters();
  void set_has_instancecollection();
  void set_has_collection();
  void set_has_scene();

  inline bool has_subtype() const;
  void clear_subtype();
  inline void clear_has_subtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::AdditionalProperties > additionalproperties_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::CreateDOM::VisualBinding* visual_;
  int type_;
  union SubtypeUnion {
    SubtypeUnion() {}
    ::CreateDOM::PhysicsMaterial* physicsmaterial_;
    ::CreateDOM::ConvexHull* convexhull_;
    ::CreateDOM::TriangleMesh* trianglemesh_;
    ::CreateDOM::HeightField* heightfield_;
    ::CreateDOM::RigidBody* rigidbody_;
    ::CreateDOM::Joint* joint_;
    ::CreateDOM::BodyPairFilters* bodypairfilters_;
    ::CreateDOM::InstanceCollection* instancecollection_;
    ::CreateDOM::Collection* collection_;
    ::CreateDOM::Scene* scene_;
  } subtype_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MeshScale : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.MeshScale) */ {
 public:
  MeshScale();
  virtual ~MeshScale();

  MeshScale(const MeshScale& from);

  inline MeshScale& operator=(const MeshScale& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MeshScale(MeshScale&& from) noexcept
    : MeshScale() {
    *this = ::std::move(from);
  }

  inline MeshScale& operator=(MeshScale&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MeshScale& default_instance();

  static inline const MeshScale* internal_default_instance() {
    return reinterpret_cast<const MeshScale*>(
               &_MeshScale_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(MeshScale* other);
  friend void swap(MeshScale& a, MeshScale& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MeshScale* New() const PROTOBUF_FINAL { return New(NULL); }

  MeshScale* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MeshScale& from);
  void MergeFrom(const MeshScale& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MeshScale* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CreateDOM.Vec3 scale = 1;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 1;
  const ::CreateDOM::Vec3& scale() const;
  ::CreateDOM::Vec3* mutable_scale();
  ::CreateDOM::Vec3* release_scale();
  void set_allocated_scale(::CreateDOM::Vec3* scale);

  // .CreateDOM.Quat rotation = 2;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 2;
  const ::CreateDOM::Quat& rotation() const;
  ::CreateDOM::Quat* mutable_rotation();
  ::CreateDOM::Quat* release_rotation();
  void set_allocated_rotation(::CreateDOM::Quat* rotation);

  // @@protoc_insertion_point(class_scope:CreateDOM.MeshScale)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::CreateDOM::Vec3* scale_;
  ::CreateDOM::Quat* rotation_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PhysicsMaterial : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.PhysicsMaterial) */ {
 public:
  PhysicsMaterial();
  virtual ~PhysicsMaterial();

  PhysicsMaterial(const PhysicsMaterial& from);

  inline PhysicsMaterial& operator=(const PhysicsMaterial& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PhysicsMaterial(PhysicsMaterial&& from) noexcept
    : PhysicsMaterial() {
    *this = ::std::move(from);
  }

  inline PhysicsMaterial& operator=(PhysicsMaterial&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PhysicsMaterial& default_instance();

  static inline const PhysicsMaterial* internal_default_instance() {
    return reinterpret_cast<const PhysicsMaterial*>(
               &_PhysicsMaterial_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(PhysicsMaterial* other);
  friend void swap(PhysicsMaterial& a, PhysicsMaterial& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PhysicsMaterial* New() const PROTOBUF_FINAL { return New(NULL); }

  PhysicsMaterial* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PhysicsMaterial& from);
  void MergeFrom(const PhysicsMaterial& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PhysicsMaterial* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool disableFriction = 1;
  void clear_disablefriction();
  static const int kDisableFrictionFieldNumber = 1;
  bool disablefriction() const;
  void set_disablefriction(bool value);

  // bool disableStrongFriction = 2;
  void clear_disablestrongfriction();
  static const int kDisableStrongFrictionFieldNumber = 2;
  bool disablestrongfriction() const;
  void set_disablestrongfriction(bool value);

  // float dynamicFriction = 3;
  void clear_dynamicfriction();
  static const int kDynamicFrictionFieldNumber = 3;
  float dynamicfriction() const;
  void set_dynamicfriction(float value);

  // float staticFriction = 4;
  void clear_staticfriction();
  static const int kStaticFrictionFieldNumber = 4;
  float staticfriction() const;
  void set_staticfriction(float value);

  // float restitution = 5;
  void clear_restitution();
  static const int kRestitutionFieldNumber = 5;
  float restitution() const;
  void set_restitution(float value);

  // @@protoc_insertion_point(class_scope:CreateDOM.PhysicsMaterial)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool disablefriction_;
  bool disablestrongfriction_;
  float dynamicfriction_;
  float staticfriction_;
  float restitution_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConvexHull : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.ConvexHull) */ {
 public:
  ConvexHull();
  virtual ~ConvexHull();

  ConvexHull(const ConvexHull& from);

  inline ConvexHull& operator=(const ConvexHull& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConvexHull(ConvexHull&& from) noexcept
    : ConvexHull() {
    *this = ::std::move(from);
  }

  inline ConvexHull& operator=(ConvexHull&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConvexHull& default_instance();

  static inline const ConvexHull* internal_default_instance() {
    return reinterpret_cast<const ConvexHull*>(
               &_ConvexHull_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ConvexHull* other);
  friend void swap(ConvexHull& a, ConvexHull& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConvexHull* New() const PROTOBUF_FINAL { return New(NULL); }

  ConvexHull* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConvexHull& from);
  void MergeFrom(const ConvexHull& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConvexHull* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CreateDOM.Vec3 points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  const ::CreateDOM::Vec3& points(int index) const;
  ::CreateDOM::Vec3* mutable_points(int index);
  ::CreateDOM::Vec3* add_points();
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::Vec3 >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::CreateDOM::Vec3 >&
      points() const;

  // @@protoc_insertion_point(class_scope:CreateDOM.ConvexHull)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::Vec3 > points_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TriangleMesh : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.TriangleMesh) */ {
 public:
  TriangleMesh();
  virtual ~TriangleMesh();

  TriangleMesh(const TriangleMesh& from);

  inline TriangleMesh& operator=(const TriangleMesh& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TriangleMesh(TriangleMesh&& from) noexcept
    : TriangleMesh() {
    *this = ::std::move(from);
  }

  inline TriangleMesh& operator=(TriangleMesh&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TriangleMesh& default_instance();

  static inline const TriangleMesh* internal_default_instance() {
    return reinterpret_cast<const TriangleMesh*>(
               &_TriangleMesh_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(TriangleMesh* other);
  friend void swap(TriangleMesh& a, TriangleMesh& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TriangleMesh* New() const PROTOBUF_FINAL { return New(NULL); }

  TriangleMesh* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TriangleMesh& from);
  void MergeFrom(const TriangleMesh& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TriangleMesh* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CreateDOM.Vec3 points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  const ::CreateDOM::Vec3& points(int index) const;
  ::CreateDOM::Vec3* mutable_points(int index);
  ::CreateDOM::Vec3* add_points();
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::Vec3 >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::CreateDOM::Vec3 >&
      points() const;

  // repeated uint32 triangles = 2;
  int triangles_size() const;
  void clear_triangles();
  static const int kTrianglesFieldNumber = 2;
  ::google::protobuf::uint32 triangles(int index) const;
  void set_triangles(int index, ::google::protobuf::uint32 value);
  void add_triangles(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      triangles() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_triangles();

  // repeated uint32 materialIndices = 3;
  int materialindices_size() const;
  void clear_materialindices();
  static const int kMaterialIndicesFieldNumber = 3;
  ::google::protobuf::uint32 materialindices(int index) const;
  void set_materialindices(int index, ::google::protobuf::uint32 value);
  void add_materialindices(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      materialindices() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_materialindices();

  // @@protoc_insertion_point(class_scope:CreateDOM.TriangleMesh)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::Vec3 > points_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > triangles_;
  mutable int _triangles_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > materialindices_;
  mutable int _materialindices_cached_byte_size_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeightField : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.HeightField) */ {
 public:
  HeightField();
  virtual ~HeightField();

  HeightField(const HeightField& from);

  inline HeightField& operator=(const HeightField& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeightField(HeightField&& from) noexcept
    : HeightField() {
    *this = ::std::move(from);
  }

  inline HeightField& operator=(HeightField&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeightField& default_instance();

  static inline const HeightField* internal_default_instance() {
    return reinterpret_cast<const HeightField*>(
               &_HeightField_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(HeightField* other);
  friend void swap(HeightField& a, HeightField& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeightField* New() const PROTOBUF_FINAL { return New(NULL); }

  HeightField* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HeightField& from);
  void MergeFrom(const HeightField& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HeightField* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 samples = 3;
  int samples_size() const;
  void clear_samples();
  static const int kSamplesFieldNumber = 3;
  ::google::protobuf::uint32 samples(int index) const;
  void set_samples(int index, ::google::protobuf::uint32 value);
  void add_samples(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      samples() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_samples();

  // repeated uint32 metaData = 4;
  int metadata_size() const;
  void clear_metadata();
  static const int kMetaDataFieldNumber = 4;
  ::google::protobuf::uint32 metadata(int index) const;
  void set_metadata(int index, ::google::protobuf::uint32 value);
  void add_metadata(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      metadata() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_metadata();

  // uint32 rowCount = 1;
  void clear_rowcount();
  static const int kRowCountFieldNumber = 1;
  ::google::protobuf::uint32 rowcount() const;
  void set_rowcount(::google::protobuf::uint32 value);

  // uint32 columnCount = 2;
  void clear_columncount();
  static const int kColumnCountFieldNumber = 2;
  ::google::protobuf::uint32 columncount() const;
  void set_columncount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CreateDOM.HeightField)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > samples_;
  mutable int _samples_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > metadata_;
  mutable int _metadata_cached_byte_size_;
  ::google::protobuf::uint32 rowcount_;
  ::google::protobuf::uint32 columncount_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Geometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.Geometry) */ {
 public:
  Geometry();
  virtual ~Geometry();

  Geometry(const Geometry& from);

  inline Geometry& operator=(const Geometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Geometry(Geometry&& from) noexcept
    : Geometry() {
    *this = ::std::move(from);
  }

  inline Geometry& operator=(Geometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Geometry& default_instance();

  enum SubtypeCase {
    kBoxGeometry = 2,
    kSphereGeometry = 3,
    kCapsuleGeometry = 4,
    kCylinderGeometry = 5,
    kConvexHullGeometry = 6,
    kTriangleMeshGeometry = 7,
    kHeightFieldGeometry = 8,
    kPlaneGeometry = 9,
    SUBTYPE_NOT_SET = 0,
  };

  static inline const Geometry* internal_default_instance() {
    return reinterpret_cast<const Geometry*>(
               &_Geometry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Geometry* other);
  friend void swap(Geometry& a, Geometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Geometry* New() const PROTOBUF_FINAL { return New(NULL); }

  Geometry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Geometry& from);
  void MergeFrom(const Geometry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Geometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CreateDOM.GeometryType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::CreateDOM::GeometryType type() const;
  void set_type(::CreateDOM::GeometryType value);

  // .CreateDOM.BoxGeometry boxGeometry = 2;
  bool has_boxgeometry() const;
  void clear_boxgeometry();
  static const int kBoxGeometryFieldNumber = 2;
  const ::CreateDOM::BoxGeometry& boxgeometry() const;
  ::CreateDOM::BoxGeometry* mutable_boxgeometry();
  ::CreateDOM::BoxGeometry* release_boxgeometry();
  void set_allocated_boxgeometry(::CreateDOM::BoxGeometry* boxgeometry);

  // .CreateDOM.SphereGeometry sphereGeometry = 3;
  bool has_spheregeometry() const;
  void clear_spheregeometry();
  static const int kSphereGeometryFieldNumber = 3;
  const ::CreateDOM::SphereGeometry& spheregeometry() const;
  ::CreateDOM::SphereGeometry* mutable_spheregeometry();
  ::CreateDOM::SphereGeometry* release_spheregeometry();
  void set_allocated_spheregeometry(::CreateDOM::SphereGeometry* spheregeometry);

  // .CreateDOM.CapsuleGeometry capsuleGeometry = 4;
  bool has_capsulegeometry() const;
  void clear_capsulegeometry();
  static const int kCapsuleGeometryFieldNumber = 4;
  const ::CreateDOM::CapsuleGeometry& capsulegeometry() const;
  ::CreateDOM::CapsuleGeometry* mutable_capsulegeometry();
  ::CreateDOM::CapsuleGeometry* release_capsulegeometry();
  void set_allocated_capsulegeometry(::CreateDOM::CapsuleGeometry* capsulegeometry);

  // .CreateDOM.CylinderGeometry cylinderGeometry = 5;
  bool has_cylindergeometry() const;
  void clear_cylindergeometry();
  static const int kCylinderGeometryFieldNumber = 5;
  const ::CreateDOM::CylinderGeometry& cylindergeometry() const;
  ::CreateDOM::CylinderGeometry* mutable_cylindergeometry();
  ::CreateDOM::CylinderGeometry* release_cylindergeometry();
  void set_allocated_cylindergeometry(::CreateDOM::CylinderGeometry* cylindergeometry);

  // .CreateDOM.ConvexHullGeometry convexHullGeometry = 6;
  bool has_convexhullgeometry() const;
  void clear_convexhullgeometry();
  static const int kConvexHullGeometryFieldNumber = 6;
  const ::CreateDOM::ConvexHullGeometry& convexhullgeometry() const;
  ::CreateDOM::ConvexHullGeometry* mutable_convexhullgeometry();
  ::CreateDOM::ConvexHullGeometry* release_convexhullgeometry();
  void set_allocated_convexhullgeometry(::CreateDOM::ConvexHullGeometry* convexhullgeometry);

  // .CreateDOM.TriangleMeshGeometry triangleMeshGeometry = 7;
  bool has_trianglemeshgeometry() const;
  void clear_trianglemeshgeometry();
  static const int kTriangleMeshGeometryFieldNumber = 7;
  const ::CreateDOM::TriangleMeshGeometry& trianglemeshgeometry() const;
  ::CreateDOM::TriangleMeshGeometry* mutable_trianglemeshgeometry();
  ::CreateDOM::TriangleMeshGeometry* release_trianglemeshgeometry();
  void set_allocated_trianglemeshgeometry(::CreateDOM::TriangleMeshGeometry* trianglemeshgeometry);

  // .CreateDOM.HeightFieldGeometry heightFieldGeometry = 8;
  bool has_heightfieldgeometry() const;
  void clear_heightfieldgeometry();
  static const int kHeightFieldGeometryFieldNumber = 8;
  const ::CreateDOM::HeightFieldGeometry& heightfieldgeometry() const;
  ::CreateDOM::HeightFieldGeometry* mutable_heightfieldgeometry();
  ::CreateDOM::HeightFieldGeometry* release_heightfieldgeometry();
  void set_allocated_heightfieldgeometry(::CreateDOM::HeightFieldGeometry* heightfieldgeometry);

  // .CreateDOM.PlaneGeometry planeGeometry = 9;
  bool has_planegeometry() const;
  void clear_planegeometry();
  static const int kPlaneGeometryFieldNumber = 9;
  const ::CreateDOM::PlaneGeometry& planegeometry() const;
  ::CreateDOM::PlaneGeometry* mutable_planegeometry();
  ::CreateDOM::PlaneGeometry* release_planegeometry();
  void set_allocated_planegeometry(::CreateDOM::PlaneGeometry* planegeometry);

  SubtypeCase subtype_case() const;
  // @@protoc_insertion_point(class_scope:CreateDOM.Geometry)
 private:
  void set_has_boxgeometry();
  void set_has_spheregeometry();
  void set_has_capsulegeometry();
  void set_has_cylindergeometry();
  void set_has_convexhullgeometry();
  void set_has_trianglemeshgeometry();
  void set_has_heightfieldgeometry();
  void set_has_planegeometry();

  inline bool has_subtype() const;
  void clear_subtype();
  inline void clear_has_subtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int type_;
  union SubtypeUnion {
    SubtypeUnion() {}
    ::CreateDOM::BoxGeometry* boxgeometry_;
    ::CreateDOM::SphereGeometry* spheregeometry_;
    ::CreateDOM::CapsuleGeometry* capsulegeometry_;
    ::CreateDOM::CylinderGeometry* cylindergeometry_;
    ::CreateDOM::ConvexHullGeometry* convexhullgeometry_;
    ::CreateDOM::TriangleMeshGeometry* trianglemeshgeometry_;
    ::CreateDOM::HeightFieldGeometry* heightfieldgeometry_;
    ::CreateDOM::PlaneGeometry* planegeometry_;
  } subtype_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BoxGeometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.BoxGeometry) */ {
 public:
  BoxGeometry();
  virtual ~BoxGeometry();

  BoxGeometry(const BoxGeometry& from);

  inline BoxGeometry& operator=(const BoxGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoxGeometry(BoxGeometry&& from) noexcept
    : BoxGeometry() {
    *this = ::std::move(from);
  }

  inline BoxGeometry& operator=(BoxGeometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoxGeometry& default_instance();

  static inline const BoxGeometry* internal_default_instance() {
    return reinterpret_cast<const BoxGeometry*>(
               &_BoxGeometry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(BoxGeometry* other);
  friend void swap(BoxGeometry& a, BoxGeometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoxGeometry* New() const PROTOBUF_FINAL { return New(NULL); }

  BoxGeometry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BoxGeometry& from);
  void MergeFrom(const BoxGeometry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BoxGeometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CreateDOM.Vec3 dimensions = 1;
  bool has_dimensions() const;
  void clear_dimensions();
  static const int kDimensionsFieldNumber = 1;
  const ::CreateDOM::Vec3& dimensions() const;
  ::CreateDOM::Vec3* mutable_dimensions();
  ::CreateDOM::Vec3* release_dimensions();
  void set_allocated_dimensions(::CreateDOM::Vec3* dimensions);

  // @@protoc_insertion_point(class_scope:CreateDOM.BoxGeometry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::CreateDOM::Vec3* dimensions_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SphereGeometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.SphereGeometry) */ {
 public:
  SphereGeometry();
  virtual ~SphereGeometry();

  SphereGeometry(const SphereGeometry& from);

  inline SphereGeometry& operator=(const SphereGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SphereGeometry(SphereGeometry&& from) noexcept
    : SphereGeometry() {
    *this = ::std::move(from);
  }

  inline SphereGeometry& operator=(SphereGeometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SphereGeometry& default_instance();

  static inline const SphereGeometry* internal_default_instance() {
    return reinterpret_cast<const SphereGeometry*>(
               &_SphereGeometry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(SphereGeometry* other);
  friend void swap(SphereGeometry& a, SphereGeometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SphereGeometry* New() const PROTOBUF_FINAL { return New(NULL); }

  SphereGeometry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SphereGeometry& from);
  void MergeFrom(const SphereGeometry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SphereGeometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float radius = 1;
  void clear_radius();
  static const int kRadiusFieldNumber = 1;
  float radius() const;
  void set_radius(float value);

  // @@protoc_insertion_point(class_scope:CreateDOM.SphereGeometry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float radius_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CapsuleGeometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.CapsuleGeometry) */ {
 public:
  CapsuleGeometry();
  virtual ~CapsuleGeometry();

  CapsuleGeometry(const CapsuleGeometry& from);

  inline CapsuleGeometry& operator=(const CapsuleGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CapsuleGeometry(CapsuleGeometry&& from) noexcept
    : CapsuleGeometry() {
    *this = ::std::move(from);
  }

  inline CapsuleGeometry& operator=(CapsuleGeometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CapsuleGeometry& default_instance();

  static inline const CapsuleGeometry* internal_default_instance() {
    return reinterpret_cast<const CapsuleGeometry*>(
               &_CapsuleGeometry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(CapsuleGeometry* other);
  friend void swap(CapsuleGeometry& a, CapsuleGeometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CapsuleGeometry* New() const PROTOBUF_FINAL { return New(NULL); }

  CapsuleGeometry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CapsuleGeometry& from);
  void MergeFrom(const CapsuleGeometry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CapsuleGeometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float radius = 1;
  void clear_radius();
  static const int kRadiusFieldNumber = 1;
  float radius() const;
  void set_radius(float value);

  // float height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  float height() const;
  void set_height(float value);

  // @@protoc_insertion_point(class_scope:CreateDOM.CapsuleGeometry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float radius_;
  float height_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CylinderGeometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.CylinderGeometry) */ {
 public:
  CylinderGeometry();
  virtual ~CylinderGeometry();

  CylinderGeometry(const CylinderGeometry& from);

  inline CylinderGeometry& operator=(const CylinderGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CylinderGeometry(CylinderGeometry&& from) noexcept
    : CylinderGeometry() {
    *this = ::std::move(from);
  }

  inline CylinderGeometry& operator=(CylinderGeometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CylinderGeometry& default_instance();

  static inline const CylinderGeometry* internal_default_instance() {
    return reinterpret_cast<const CylinderGeometry*>(
               &_CylinderGeometry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(CylinderGeometry* other);
  friend void swap(CylinderGeometry& a, CylinderGeometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CylinderGeometry* New() const PROTOBUF_FINAL { return New(NULL); }

  CylinderGeometry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CylinderGeometry& from);
  void MergeFrom(const CylinderGeometry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CylinderGeometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float radius = 1;
  void clear_radius();
  static const int kRadiusFieldNumber = 1;
  float radius() const;
  void set_radius(float value);

  // float height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  float height() const;
  void set_height(float value);

  // @@protoc_insertion_point(class_scope:CreateDOM.CylinderGeometry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float radius_;
  float height_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConvexHullGeometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.ConvexHullGeometry) */ {
 public:
  ConvexHullGeometry();
  virtual ~ConvexHullGeometry();

  ConvexHullGeometry(const ConvexHullGeometry& from);

  inline ConvexHullGeometry& operator=(const ConvexHullGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConvexHullGeometry(ConvexHullGeometry&& from) noexcept
    : ConvexHullGeometry() {
    *this = ::std::move(from);
  }

  inline ConvexHullGeometry& operator=(ConvexHullGeometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConvexHullGeometry& default_instance();

  static inline const ConvexHullGeometry* internal_default_instance() {
    return reinterpret_cast<const ConvexHullGeometry*>(
               &_ConvexHullGeometry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(ConvexHullGeometry* other);
  friend void swap(ConvexHullGeometry& a, ConvexHullGeometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConvexHullGeometry* New() const PROTOBUF_FINAL { return New(NULL); }

  ConvexHullGeometry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConvexHullGeometry& from);
  void MergeFrom(const ConvexHullGeometry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConvexHullGeometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string convexMesh = 2;
  void clear_convexmesh();
  static const int kConvexMeshFieldNumber = 2;
  const ::std::string& convexmesh() const;
  void set_convexmesh(const ::std::string& value);
  #if LANG_CXX11
  void set_convexmesh(::std::string&& value);
  #endif
  void set_convexmesh(const char* value);
  void set_convexmesh(const char* value, size_t size);
  ::std::string* mutable_convexmesh();
  ::std::string* release_convexmesh();
  void set_allocated_convexmesh(::std::string* convexmesh);

  // .CreateDOM.MeshScale scale = 1;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 1;
  const ::CreateDOM::MeshScale& scale() const;
  ::CreateDOM::MeshScale* mutable_scale();
  ::CreateDOM::MeshScale* release_scale();
  void set_allocated_scale(::CreateDOM::MeshScale* scale);

  // @@protoc_insertion_point(class_scope:CreateDOM.ConvexHullGeometry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr convexmesh_;
  ::CreateDOM::MeshScale* scale_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TriangleMeshGeometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.TriangleMeshGeometry) */ {
 public:
  TriangleMeshGeometry();
  virtual ~TriangleMeshGeometry();

  TriangleMeshGeometry(const TriangleMeshGeometry& from);

  inline TriangleMeshGeometry& operator=(const TriangleMeshGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TriangleMeshGeometry(TriangleMeshGeometry&& from) noexcept
    : TriangleMeshGeometry() {
    *this = ::std::move(from);
  }

  inline TriangleMeshGeometry& operator=(TriangleMeshGeometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TriangleMeshGeometry& default_instance();

  static inline const TriangleMeshGeometry* internal_default_instance() {
    return reinterpret_cast<const TriangleMeshGeometry*>(
               &_TriangleMeshGeometry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(TriangleMeshGeometry* other);
  friend void swap(TriangleMeshGeometry& a, TriangleMeshGeometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TriangleMeshGeometry* New() const PROTOBUF_FINAL { return New(NULL); }

  TriangleMeshGeometry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TriangleMeshGeometry& from);
  void MergeFrom(const TriangleMeshGeometry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TriangleMeshGeometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string triangleMesh = 2;
  void clear_trianglemesh();
  static const int kTriangleMeshFieldNumber = 2;
  const ::std::string& trianglemesh() const;
  void set_trianglemesh(const ::std::string& value);
  #if LANG_CXX11
  void set_trianglemesh(::std::string&& value);
  #endif
  void set_trianglemesh(const char* value);
  void set_trianglemesh(const char* value, size_t size);
  ::std::string* mutable_trianglemesh();
  ::std::string* release_trianglemesh();
  void set_allocated_trianglemesh(::std::string* trianglemesh);

  // .CreateDOM.MeshScale scale = 1;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 1;
  const ::CreateDOM::MeshScale& scale() const;
  ::CreateDOM::MeshScale* mutable_scale();
  ::CreateDOM::MeshScale* release_scale();
  void set_allocated_scale(::CreateDOM::MeshScale* scale);

  // bool doubleSided = 3;
  void clear_doublesided();
  static const int kDoubleSidedFieldNumber = 3;
  bool doublesided() const;
  void set_doublesided(bool value);

  // @@protoc_insertion_point(class_scope:CreateDOM.TriangleMeshGeometry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr trianglemesh_;
  ::CreateDOM::MeshScale* scale_;
  bool doublesided_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeightFieldGeometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.HeightFieldGeometry) */ {
 public:
  HeightFieldGeometry();
  virtual ~HeightFieldGeometry();

  HeightFieldGeometry(const HeightFieldGeometry& from);

  inline HeightFieldGeometry& operator=(const HeightFieldGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeightFieldGeometry(HeightFieldGeometry&& from) noexcept
    : HeightFieldGeometry() {
    *this = ::std::move(from);
  }

  inline HeightFieldGeometry& operator=(HeightFieldGeometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeightFieldGeometry& default_instance();

  static inline const HeightFieldGeometry* internal_default_instance() {
    return reinterpret_cast<const HeightFieldGeometry*>(
               &_HeightFieldGeometry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(HeightFieldGeometry* other);
  friend void swap(HeightFieldGeometry& a, HeightFieldGeometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeightFieldGeometry* New() const PROTOBUF_FINAL { return New(NULL); }

  HeightFieldGeometry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HeightFieldGeometry& from);
  void MergeFrom(const HeightFieldGeometry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HeightFieldGeometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string heightField = 1;
  void clear_heightfield();
  static const int kHeightFieldFieldNumber = 1;
  const ::std::string& heightfield() const;
  void set_heightfield(const ::std::string& value);
  #if LANG_CXX11
  void set_heightfield(::std::string&& value);
  #endif
  void set_heightfield(const char* value);
  void set_heightfield(const char* value, size_t size);
  ::std::string* mutable_heightfield();
  ::std::string* release_heightfield();
  void set_allocated_heightfield(::std::string* heightfield);

  // float heightScale = 2;
  void clear_heightscale();
  static const int kHeightScaleFieldNumber = 2;
  float heightscale() const;
  void set_heightscale(float value);

  // float rowScale = 3;
  void clear_rowscale();
  static const int kRowScaleFieldNumber = 3;
  float rowscale() const;
  void set_rowscale(float value);

  // float columnScale = 4;
  void clear_columnscale();
  static const int kColumnScaleFieldNumber = 4;
  float columnscale() const;
  void set_columnscale(float value);

  // bool doubleSided = 5;
  void clear_doublesided();
  static const int kDoubleSidedFieldNumber = 5;
  bool doublesided() const;
  void set_doublesided(bool value);

  // @@protoc_insertion_point(class_scope:CreateDOM.HeightFieldGeometry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr heightfield_;
  float heightscale_;
  float rowscale_;
  float columnscale_;
  bool doublesided_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlaneGeometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.PlaneGeometry) */ {
 public:
  PlaneGeometry();
  virtual ~PlaneGeometry();

  PlaneGeometry(const PlaneGeometry& from);

  inline PlaneGeometry& operator=(const PlaneGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlaneGeometry(PlaneGeometry&& from) noexcept
    : PlaneGeometry() {
    *this = ::std::move(from);
  }

  inline PlaneGeometry& operator=(PlaneGeometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlaneGeometry& default_instance();

  static inline const PlaneGeometry* internal_default_instance() {
    return reinterpret_cast<const PlaneGeometry*>(
               &_PlaneGeometry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(PlaneGeometry* other);
  friend void swap(PlaneGeometry& a, PlaneGeometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlaneGeometry* New() const PROTOBUF_FINAL { return New(NULL); }

  PlaneGeometry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlaneGeometry& from);
  void MergeFrom(const PlaneGeometry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlaneGeometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CreateDOM.PlaneGeometry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GeometryInstance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.GeometryInstance) */ {
 public:
  GeometryInstance();
  virtual ~GeometryInstance();

  GeometryInstance(const GeometryInstance& from);

  inline GeometryInstance& operator=(const GeometryInstance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GeometryInstance(GeometryInstance&& from) noexcept
    : GeometryInstance() {
    *this = ::std::move(from);
  }

  inline GeometryInstance& operator=(GeometryInstance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GeometryInstance& default_instance();

  static inline const GeometryInstance* internal_default_instance() {
    return reinterpret_cast<const GeometryInstance*>(
               &_GeometryInstance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(GeometryInstance* other);
  friend void swap(GeometryInstance& a, GeometryInstance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GeometryInstance* New() const PROTOBUF_FINAL { return New(NULL); }

  GeometryInstance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GeometryInstance& from);
  void MergeFrom(const GeometryInstance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GeometryInstance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string materials = 2;
  int materials_size() const;
  void clear_materials();
  static const int kMaterialsFieldNumber = 2;
  const ::std::string& materials(int index) const;
  ::std::string* mutable_materials(int index);
  void set_materials(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_materials(int index, ::std::string&& value);
  #endif
  void set_materials(int index, const char* value);
  void set_materials(int index, const char* value, size_t size);
  ::std::string* add_materials();
  void add_materials(const ::std::string& value);
  #if LANG_CXX11
  void add_materials(::std::string&& value);
  #endif
  void add_materials(const char* value);
  void add_materials(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& materials() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_materials();

  // string collisionFilterSettings = 4;
  void clear_collisionfiltersettings();
  static const int kCollisionFilterSettingsFieldNumber = 4;
  const ::std::string& collisionfiltersettings() const;
  void set_collisionfiltersettings(const ::std::string& value);
  #if LANG_CXX11
  void set_collisionfiltersettings(::std::string&& value);
  #endif
  void set_collisionfiltersettings(const char* value);
  void set_collisionfiltersettings(const char* value, size_t size);
  ::std::string* mutable_collisionfiltersettings();
  ::std::string* release_collisionfiltersettings();
  void set_allocated_collisionfiltersettings(::std::string* collisionfiltersettings);

  // .CreateDOM.Geometry geometry = 1;
  bool has_geometry() const;
  void clear_geometry();
  static const int kGeometryFieldNumber = 1;
  const ::CreateDOM::Geometry& geometry() const;
  ::CreateDOM::Geometry* mutable_geometry();
  ::CreateDOM::Geometry* release_geometry();
  void set_allocated_geometry(::CreateDOM::Geometry* geometry);

  // .CreateDOM.Pose localPose = 3;
  bool has_localpose() const;
  void clear_localpose();
  static const int kLocalPoseFieldNumber = 3;
  const ::CreateDOM::Pose& localpose() const;
  ::CreateDOM::Pose* mutable_localpose();
  ::CreateDOM::Pose* release_localpose();
  void set_allocated_localpose(::CreateDOM::Pose* localpose);

  // @@protoc_insertion_point(class_scope:CreateDOM.GeometryInstance)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> materials_;
  ::google::protobuf::internal::ArenaStringPtr collisionfiltersettings_;
  ::CreateDOM::Geometry* geometry_;
  ::CreateDOM::Pose* localpose_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RigidBody : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.RigidBody) */ {
 public:
  RigidBody();
  virtual ~RigidBody();

  RigidBody(const RigidBody& from);

  inline RigidBody& operator=(const RigidBody& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RigidBody(RigidBody&& from) noexcept
    : RigidBody() {
    *this = ::std::move(from);
  }

  inline RigidBody& operator=(RigidBody&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RigidBody& default_instance();

  enum SubtypeCase {
    kRigidStatic = 3,
    kRigidDynamic = 4,
    SUBTYPE_NOT_SET = 0,
  };

  static inline const RigidBody* internal_default_instance() {
    return reinterpret_cast<const RigidBody*>(
               &_RigidBody_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(RigidBody* other);
  friend void swap(RigidBody& a, RigidBody& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RigidBody* New() const PROTOBUF_FINAL { return New(NULL); }

  RigidBody* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RigidBody& from);
  void MergeFrom(const RigidBody& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RigidBody* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CreateDOM.GeometryInstance geometryInstances = 1;
  int geometryinstances_size() const;
  void clear_geometryinstances();
  static const int kGeometryInstancesFieldNumber = 1;
  const ::CreateDOM::GeometryInstance& geometryinstances(int index) const;
  ::CreateDOM::GeometryInstance* mutable_geometryinstances(int index);
  ::CreateDOM::GeometryInstance* add_geometryinstances();
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::GeometryInstance >*
      mutable_geometryinstances();
  const ::google::protobuf::RepeatedPtrField< ::CreateDOM::GeometryInstance >&
      geometryinstances() const;

  // .CreateDOM.Pose globalPose = 2;
  bool has_globalpose() const;
  void clear_globalpose();
  static const int kGlobalPoseFieldNumber = 2;
  const ::CreateDOM::Pose& globalpose() const;
  ::CreateDOM::Pose* mutable_globalpose();
  ::CreateDOM::Pose* release_globalpose();
  void set_allocated_globalpose(::CreateDOM::Pose* globalpose);

  // .CreateDOM.RigidStatic rigidStatic = 3;
  bool has_rigidstatic() const;
  void clear_rigidstatic();
  static const int kRigidStaticFieldNumber = 3;
  const ::CreateDOM::RigidStatic& rigidstatic() const;
  ::CreateDOM::RigidStatic* mutable_rigidstatic();
  ::CreateDOM::RigidStatic* release_rigidstatic();
  void set_allocated_rigidstatic(::CreateDOM::RigidStatic* rigidstatic);

  // .CreateDOM.RigidDynamic rigidDynamic = 4;
  bool has_rigiddynamic() const;
  void clear_rigiddynamic();
  static const int kRigidDynamicFieldNumber = 4;
  const ::CreateDOM::RigidDynamic& rigiddynamic() const;
  ::CreateDOM::RigidDynamic* mutable_rigiddynamic();
  ::CreateDOM::RigidDynamic* release_rigiddynamic();
  void set_allocated_rigiddynamic(::CreateDOM::RigidDynamic* rigiddynamic);

  SubtypeCase subtype_case() const;
  // @@protoc_insertion_point(class_scope:CreateDOM.RigidBody)
 private:
  void set_has_rigidstatic();
  void set_has_rigiddynamic();

  inline bool has_subtype() const;
  void clear_subtype();
  inline void clear_has_subtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::GeometryInstance > geometryinstances_;
  ::CreateDOM::Pose* globalpose_;
  union SubtypeUnion {
    SubtypeUnion() {}
    ::CreateDOM::RigidStatic* rigidstatic_;
    ::CreateDOM::RigidDynamic* rigiddynamic_;
  } subtype_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RigidStatic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.RigidStatic) */ {
 public:
  RigidStatic();
  virtual ~RigidStatic();

  RigidStatic(const RigidStatic& from);

  inline RigidStatic& operator=(const RigidStatic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RigidStatic(RigidStatic&& from) noexcept
    : RigidStatic() {
    *this = ::std::move(from);
  }

  inline RigidStatic& operator=(RigidStatic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RigidStatic& default_instance();

  static inline const RigidStatic* internal_default_instance() {
    return reinterpret_cast<const RigidStatic*>(
               &_RigidStatic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(RigidStatic* other);
  friend void swap(RigidStatic& a, RigidStatic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RigidStatic* New() const PROTOBUF_FINAL { return New(NULL); }

  RigidStatic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RigidStatic& from);
  void MergeFrom(const RigidStatic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RigidStatic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CreateDOM.RigidStatic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RigidDynamic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.RigidDynamic) */ {
 public:
  RigidDynamic();
  virtual ~RigidDynamic();

  RigidDynamic(const RigidDynamic& from);

  inline RigidDynamic& operator=(const RigidDynamic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RigidDynamic(RigidDynamic&& from) noexcept
    : RigidDynamic() {
    *this = ::std::move(from);
  }

  inline RigidDynamic& operator=(RigidDynamic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RigidDynamic& default_instance();

  static inline const RigidDynamic* internal_default_instance() {
    return reinterpret_cast<const RigidDynamic*>(
               &_RigidDynamic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(RigidDynamic* other);
  friend void swap(RigidDynamic& a, RigidDynamic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RigidDynamic* New() const PROTOBUF_FINAL { return New(NULL); }

  RigidDynamic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RigidDynamic& from);
  void MergeFrom(const RigidDynamic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RigidDynamic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CreateDOM.Pose centerOfMassLocalPose = 2;
  bool has_centerofmasslocalpose() const;
  void clear_centerofmasslocalpose();
  static const int kCenterOfMassLocalPoseFieldNumber = 2;
  const ::CreateDOM::Pose& centerofmasslocalpose() const;
  ::CreateDOM::Pose* mutable_centerofmasslocalpose();
  ::CreateDOM::Pose* release_centerofmasslocalpose();
  void set_allocated_centerofmasslocalpose(::CreateDOM::Pose* centerofmasslocalpose);

  // .CreateDOM.Vec3 massSpaceInertiaTensor = 4;
  bool has_massspaceinertiatensor() const;
  void clear_massspaceinertiatensor();
  static const int kMassSpaceInertiaTensorFieldNumber = 4;
  const ::CreateDOM::Vec3& massspaceinertiatensor() const;
  ::CreateDOM::Vec3* mutable_massspaceinertiatensor();
  ::CreateDOM::Vec3* release_massspaceinertiatensor();
  void set_allocated_massspaceinertiatensor(::CreateDOM::Vec3* massspaceinertiatensor);

  // .CreateDOM.Vec3 linearVelocity = 5;
  bool has_linearvelocity() const;
  void clear_linearvelocity();
  static const int kLinearVelocityFieldNumber = 5;
  const ::CreateDOM::Vec3& linearvelocity() const;
  ::CreateDOM::Vec3* mutable_linearvelocity();
  ::CreateDOM::Vec3* release_linearvelocity();
  void set_allocated_linearvelocity(::CreateDOM::Vec3* linearvelocity);

  // .CreateDOM.Vec3 angularVelocity = 6;
  bool has_angularvelocity() const;
  void clear_angularvelocity();
  static const int kAngularVelocityFieldNumber = 6;
  const ::CreateDOM::Vec3& angularvelocity() const;
  ::CreateDOM::Vec3* mutable_angularvelocity();
  ::CreateDOM::Vec3* release_angularvelocity();
  void set_allocated_angularvelocity(::CreateDOM::Vec3* angularvelocity);

  // float mass = 3;
  void clear_mass();
  static const int kMassFieldNumber = 3;
  float mass() const;
  void set_mass(float value);

  // bool disableGravity = 1;
  void clear_disablegravity();
  static const int kDisableGravityFieldNumber = 1;
  bool disablegravity() const;
  void set_disablegravity(bool value);

  // bool kinematic = 10;
  void clear_kinematic();
  static const int kKinematicFieldNumber = 10;
  bool kinematic() const;
  void set_kinematic(bool value);

  // float linearDamping = 7;
  void clear_lineardamping();
  static const int kLinearDampingFieldNumber = 7;
  float lineardamping() const;
  void set_lineardamping(float value);

  // float angularDamping = 8;
  void clear_angulardamping();
  static const int kAngularDampingFieldNumber = 8;
  float angulardamping() const;
  void set_angulardamping(float value);

  // float maxAngularVelocity = 9;
  void clear_maxangularvelocity();
  static const int kMaxAngularVelocityFieldNumber = 9;
  float maxangularvelocity() const;
  void set_maxangularvelocity(float value);

  // @@protoc_insertion_point(class_scope:CreateDOM.RigidDynamic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::CreateDOM::Pose* centerofmasslocalpose_;
  ::CreateDOM::Vec3* massspaceinertiatensor_;
  ::CreateDOM::Vec3* linearvelocity_;
  ::CreateDOM::Vec3* angularvelocity_;
  float mass_;
  bool disablegravity_;
  bool kinematic_;
  float lineardamping_;
  float angulardamping_;
  float maxangularvelocity_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Joint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.Joint) */ {
 public:
  Joint();
  virtual ~Joint();

  Joint(const Joint& from);

  inline Joint& operator=(const Joint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Joint(Joint&& from) noexcept
    : Joint() {
    *this = ::std::move(from);
  }

  inline Joint& operator=(Joint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Joint& default_instance();

  enum SubtypeCase {
    kFixedJoint = 6,
    kSphericalJoint = 7,
    kHingeJoint = 8,
    kPrismaticJoint = 9,
    kDistanceJoint = 10,
    kBallAndSocketJoint = 11,
    kD6Joint = 12,
    SUBTYPE_NOT_SET = 0,
  };

  static inline const Joint* internal_default_instance() {
    return reinterpret_cast<const Joint*>(
               &_Joint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(Joint* other);
  friend void swap(Joint& a, Joint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Joint* New() const PROTOBUF_FINAL { return New(NULL); }

  Joint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Joint& from);
  void MergeFrom(const Joint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Joint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string body0 = 1;
  void clear_body0();
  static const int kBody0FieldNumber = 1;
  const ::std::string& body0() const;
  void set_body0(const ::std::string& value);
  #if LANG_CXX11
  void set_body0(::std::string&& value);
  #endif
  void set_body0(const char* value);
  void set_body0(const char* value, size_t size);
  ::std::string* mutable_body0();
  ::std::string* release_body0();
  void set_allocated_body0(::std::string* body0);

  // string body1 = 2;
  void clear_body1();
  static const int kBody1FieldNumber = 2;
  const ::std::string& body1() const;
  void set_body1(const ::std::string& value);
  #if LANG_CXX11
  void set_body1(::std::string&& value);
  #endif
  void set_body1(const char* value);
  void set_body1(const char* value, size_t size);
  ::std::string* mutable_body1();
  ::std::string* release_body1();
  void set_allocated_body1(::std::string* body1);

  // .CreateDOM.Pose localpose0 = 3;
  bool has_localpose0() const;
  void clear_localpose0();
  static const int kLocalpose0FieldNumber = 3;
  const ::CreateDOM::Pose& localpose0() const;
  ::CreateDOM::Pose* mutable_localpose0();
  ::CreateDOM::Pose* release_localpose0();
  void set_allocated_localpose0(::CreateDOM::Pose* localpose0);

  // .CreateDOM.Pose localpose1 = 4;
  bool has_localpose1() const;
  void clear_localpose1();
  static const int kLocalpose1FieldNumber = 4;
  const ::CreateDOM::Pose& localpose1() const;
  ::CreateDOM::Pose* mutable_localpose1();
  ::CreateDOM::Pose* release_localpose1();
  void set_allocated_localpose1(::CreateDOM::Pose* localpose1);

  // bool collisionEnabled = 5;
  void clear_collisionenabled();
  static const int kCollisionEnabledFieldNumber = 5;
  bool collisionenabled() const;
  void set_collisionenabled(bool value);

  // .CreateDOM.FixedJoint fixedJoint = 6;
  bool has_fixedjoint() const;
  void clear_fixedjoint();
  static const int kFixedJointFieldNumber = 6;
  const ::CreateDOM::FixedJoint& fixedjoint() const;
  ::CreateDOM::FixedJoint* mutable_fixedjoint();
  ::CreateDOM::FixedJoint* release_fixedjoint();
  void set_allocated_fixedjoint(::CreateDOM::FixedJoint* fixedjoint);

  // .CreateDOM.SphericalJoint sphericalJoint = 7;
  bool has_sphericaljoint() const;
  void clear_sphericaljoint();
  static const int kSphericalJointFieldNumber = 7;
  const ::CreateDOM::SphericalJoint& sphericaljoint() const;
  ::CreateDOM::SphericalJoint* mutable_sphericaljoint();
  ::CreateDOM::SphericalJoint* release_sphericaljoint();
  void set_allocated_sphericaljoint(::CreateDOM::SphericalJoint* sphericaljoint);

  // .CreateDOM.HingeJoint hingeJoint = 8;
  bool has_hingejoint() const;
  void clear_hingejoint();
  static const int kHingeJointFieldNumber = 8;
  const ::CreateDOM::HingeJoint& hingejoint() const;
  ::CreateDOM::HingeJoint* mutable_hingejoint();
  ::CreateDOM::HingeJoint* release_hingejoint();
  void set_allocated_hingejoint(::CreateDOM::HingeJoint* hingejoint);

  // .CreateDOM.PrismaticJoint prismaticJoint = 9;
  bool has_prismaticjoint() const;
  void clear_prismaticjoint();
  static const int kPrismaticJointFieldNumber = 9;
  const ::CreateDOM::PrismaticJoint& prismaticjoint() const;
  ::CreateDOM::PrismaticJoint* mutable_prismaticjoint();
  ::CreateDOM::PrismaticJoint* release_prismaticjoint();
  void set_allocated_prismaticjoint(::CreateDOM::PrismaticJoint* prismaticjoint);

  // .CreateDOM.DistanceJoint distanceJoint = 10;
  bool has_distancejoint() const;
  void clear_distancejoint();
  static const int kDistanceJointFieldNumber = 10;
  const ::CreateDOM::DistanceJoint& distancejoint() const;
  ::CreateDOM::DistanceJoint* mutable_distancejoint();
  ::CreateDOM::DistanceJoint* release_distancejoint();
  void set_allocated_distancejoint(::CreateDOM::DistanceJoint* distancejoint);

  // .CreateDOM.BallAndSocketJoint ballAndSocketJoint = 11;
  bool has_ballandsocketjoint() const;
  void clear_ballandsocketjoint();
  static const int kBallAndSocketJointFieldNumber = 11;
  const ::CreateDOM::BallAndSocketJoint& ballandsocketjoint() const;
  ::CreateDOM::BallAndSocketJoint* mutable_ballandsocketjoint();
  ::CreateDOM::BallAndSocketJoint* release_ballandsocketjoint();
  void set_allocated_ballandsocketjoint(::CreateDOM::BallAndSocketJoint* ballandsocketjoint);

  // .CreateDOM.D6Joint d6Joint = 12;
  bool has_d6joint() const;
  void clear_d6joint();
  static const int kD6JointFieldNumber = 12;
  const ::CreateDOM::D6Joint& d6joint() const;
  ::CreateDOM::D6Joint* mutable_d6joint();
  ::CreateDOM::D6Joint* release_d6joint();
  void set_allocated_d6joint(::CreateDOM::D6Joint* d6joint);

  SubtypeCase subtype_case() const;
  // @@protoc_insertion_point(class_scope:CreateDOM.Joint)
 private:
  void set_has_fixedjoint();
  void set_has_sphericaljoint();
  void set_has_hingejoint();
  void set_has_prismaticjoint();
  void set_has_distancejoint();
  void set_has_ballandsocketjoint();
  void set_has_d6joint();

  inline bool has_subtype() const;
  void clear_subtype();
  inline void clear_has_subtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr body0_;
  ::google::protobuf::internal::ArenaStringPtr body1_;
  ::CreateDOM::Pose* localpose0_;
  ::CreateDOM::Pose* localpose1_;
  bool collisionenabled_;
  union SubtypeUnion {
    SubtypeUnion() {}
    ::CreateDOM::FixedJoint* fixedjoint_;
    ::CreateDOM::SphericalJoint* sphericaljoint_;
    ::CreateDOM::HingeJoint* hingejoint_;
    ::CreateDOM::PrismaticJoint* prismaticjoint_;
    ::CreateDOM::DistanceJoint* distancejoint_;
    ::CreateDOM::BallAndSocketJoint* ballandsocketjoint_;
    ::CreateDOM::D6Joint* d6joint_;
  } subtype_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FixedJoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.FixedJoint) */ {
 public:
  FixedJoint();
  virtual ~FixedJoint();

  FixedJoint(const FixedJoint& from);

  inline FixedJoint& operator=(const FixedJoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FixedJoint(FixedJoint&& from) noexcept
    : FixedJoint() {
    *this = ::std::move(from);
  }

  inline FixedJoint& operator=(FixedJoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FixedJoint& default_instance();

  static inline const FixedJoint* internal_default_instance() {
    return reinterpret_cast<const FixedJoint*>(
               &_FixedJoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(FixedJoint* other);
  friend void swap(FixedJoint& a, FixedJoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FixedJoint* New() const PROTOBUF_FINAL { return New(NULL); }

  FixedJoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FixedJoint& from);
  void MergeFrom(const FixedJoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FixedJoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CreateDOM.FixedJoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SphericalJoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.SphericalJoint) */ {
 public:
  SphericalJoint();
  virtual ~SphericalJoint();

  SphericalJoint(const SphericalJoint& from);

  inline SphericalJoint& operator=(const SphericalJoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SphericalJoint(SphericalJoint&& from) noexcept
    : SphericalJoint() {
    *this = ::std::move(from);
  }

  inline SphericalJoint& operator=(SphericalJoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SphericalJoint& default_instance();

  static inline const SphericalJoint* internal_default_instance() {
    return reinterpret_cast<const SphericalJoint*>(
               &_SphericalJoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(SphericalJoint* other);
  friend void swap(SphericalJoint& a, SphericalJoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SphericalJoint* New() const PROTOBUF_FINAL { return New(NULL); }

  SphericalJoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SphericalJoint& from);
  void MergeFrom(const SphericalJoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SphericalJoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float limitY = 1;
  void clear_limity();
  static const int kLimitYFieldNumber = 1;
  float limity() const;
  void set_limity(float value);

  // float limitZ = 2;
  void clear_limitz();
  static const int kLimitZFieldNumber = 2;
  float limitz() const;
  void set_limitz(float value);

  // @@protoc_insertion_point(class_scope:CreateDOM.SphericalJoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float limity_;
  float limitz_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HingeJoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.HingeJoint) */ {
 public:
  HingeJoint();
  virtual ~HingeJoint();

  HingeJoint(const HingeJoint& from);

  inline HingeJoint& operator=(const HingeJoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HingeJoint(HingeJoint&& from) noexcept
    : HingeJoint() {
    *this = ::std::move(from);
  }

  inline HingeJoint& operator=(HingeJoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HingeJoint& default_instance();

  static inline const HingeJoint* internal_default_instance() {
    return reinterpret_cast<const HingeJoint*>(
               &_HingeJoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(HingeJoint* other);
  friend void swap(HingeJoint& a, HingeJoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HingeJoint* New() const PROTOBUF_FINAL { return New(NULL); }

  HingeJoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HingeJoint& from);
  void MergeFrom(const HingeJoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HingeJoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float limtLow = 1;
  void clear_limtlow();
  static const int kLimtLowFieldNumber = 1;
  float limtlow() const;
  void set_limtlow(float value);

  // float limitHigh = 2;
  void clear_limithigh();
  static const int kLimitHighFieldNumber = 2;
  float limithigh() const;
  void set_limithigh(float value);

  // @@protoc_insertion_point(class_scope:CreateDOM.HingeJoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float limtlow_;
  float limithigh_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PrismaticJoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.PrismaticJoint) */ {
 public:
  PrismaticJoint();
  virtual ~PrismaticJoint();

  PrismaticJoint(const PrismaticJoint& from);

  inline PrismaticJoint& operator=(const PrismaticJoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PrismaticJoint(PrismaticJoint&& from) noexcept
    : PrismaticJoint() {
    *this = ::std::move(from);
  }

  inline PrismaticJoint& operator=(PrismaticJoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PrismaticJoint& default_instance();

  static inline const PrismaticJoint* internal_default_instance() {
    return reinterpret_cast<const PrismaticJoint*>(
               &_PrismaticJoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(PrismaticJoint* other);
  friend void swap(PrismaticJoint& a, PrismaticJoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PrismaticJoint* New() const PROTOBUF_FINAL { return New(NULL); }

  PrismaticJoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PrismaticJoint& from);
  void MergeFrom(const PrismaticJoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PrismaticJoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float limitLow = 1;
  void clear_limitlow();
  static const int kLimitLowFieldNumber = 1;
  float limitlow() const;
  void set_limitlow(float value);

  // float limitHigh = 2;
  void clear_limithigh();
  static const int kLimitHighFieldNumber = 2;
  float limithigh() const;
  void set_limithigh(float value);

  // @@protoc_insertion_point(class_scope:CreateDOM.PrismaticJoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float limitlow_;
  float limithigh_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DistanceJoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.DistanceJoint) */ {
 public:
  DistanceJoint();
  virtual ~DistanceJoint();

  DistanceJoint(const DistanceJoint& from);

  inline DistanceJoint& operator=(const DistanceJoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DistanceJoint(DistanceJoint&& from) noexcept
    : DistanceJoint() {
    *this = ::std::move(from);
  }

  inline DistanceJoint& operator=(DistanceJoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DistanceJoint& default_instance();

  static inline const DistanceJoint* internal_default_instance() {
    return reinterpret_cast<const DistanceJoint*>(
               &_DistanceJoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(DistanceJoint* other);
  friend void swap(DistanceJoint& a, DistanceJoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DistanceJoint* New() const PROTOBUF_FINAL { return New(NULL); }

  DistanceJoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DistanceJoint& from);
  void MergeFrom(const DistanceJoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DistanceJoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float distanceLow = 1;
  void clear_distancelow();
  static const int kDistanceLowFieldNumber = 1;
  float distancelow() const;
  void set_distancelow(float value);

  // float distanceHigh = 2;
  void clear_distancehigh();
  static const int kDistanceHighFieldNumber = 2;
  float distancehigh() const;
  void set_distancehigh(float value);

  // @@protoc_insertion_point(class_scope:CreateDOM.DistanceJoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float distancelow_;
  float distancehigh_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BallAndSocketJoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.BallAndSocketJoint) */ {
 public:
  BallAndSocketJoint();
  virtual ~BallAndSocketJoint();

  BallAndSocketJoint(const BallAndSocketJoint& from);

  inline BallAndSocketJoint& operator=(const BallAndSocketJoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BallAndSocketJoint(BallAndSocketJoint&& from) noexcept
    : BallAndSocketJoint() {
    *this = ::std::move(from);
  }

  inline BallAndSocketJoint& operator=(BallAndSocketJoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BallAndSocketJoint& default_instance();

  static inline const BallAndSocketJoint* internal_default_instance() {
    return reinterpret_cast<const BallAndSocketJoint*>(
               &_BallAndSocketJoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(BallAndSocketJoint* other);
  friend void swap(BallAndSocketJoint& a, BallAndSocketJoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BallAndSocketJoint* New() const PROTOBUF_FINAL { return New(NULL); }

  BallAndSocketJoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BallAndSocketJoint& from);
  void MergeFrom(const BallAndSocketJoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BallAndSocketJoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float limitXLow = 1;
  void clear_limitxlow();
  static const int kLimitXLowFieldNumber = 1;
  float limitxlow() const;
  void set_limitxlow(float value);

  // float limitXHigh = 2;
  void clear_limitxhigh();
  static const int kLimitXHighFieldNumber = 2;
  float limitxhigh() const;
  void set_limitxhigh(float value);

  // float limitY = 3;
  void clear_limity();
  static const int kLimitYFieldNumber = 3;
  float limity() const;
  void set_limity(float value);

  // float limitZ = 4;
  void clear_limitz();
  static const int kLimitZFieldNumber = 4;
  float limitz() const;
  void set_limitz(float value);

  // @@protoc_insertion_point(class_scope:CreateDOM.BallAndSocketJoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float limitxlow_;
  float limitxhigh_;
  float limity_;
  float limitz_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class D6Joint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.D6Joint) */ {
 public:
  D6Joint();
  virtual ~D6Joint();

  D6Joint(const D6Joint& from);

  inline D6Joint& operator=(const D6Joint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  D6Joint(D6Joint&& from) noexcept
    : D6Joint() {
    *this = ::std::move(from);
  }

  inline D6Joint& operator=(D6Joint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const D6Joint& default_instance();

  static inline const D6Joint* internal_default_instance() {
    return reinterpret_cast<const D6Joint*>(
               &_D6Joint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(D6Joint* other);
  friend void swap(D6Joint& a, D6Joint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline D6Joint* New() const PROTOBUF_FINAL { return New(NULL); }

  D6Joint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const D6Joint& from);
  void MergeFrom(const D6Joint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(D6Joint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CreateDOM.D6Joint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BodyPairFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.BodyPairFilter) */ {
 public:
  BodyPairFilter();
  virtual ~BodyPairFilter();

  BodyPairFilter(const BodyPairFilter& from);

  inline BodyPairFilter& operator=(const BodyPairFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BodyPairFilter(BodyPairFilter&& from) noexcept
    : BodyPairFilter() {
    *this = ::std::move(from);
  }

  inline BodyPairFilter& operator=(BodyPairFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BodyPairFilter& default_instance();

  static inline const BodyPairFilter* internal_default_instance() {
    return reinterpret_cast<const BodyPairFilter*>(
               &_BodyPairFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(BodyPairFilter* other);
  friend void swap(BodyPairFilter& a, BodyPairFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BodyPairFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  BodyPairFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BodyPairFilter& from);
  void MergeFrom(const BodyPairFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BodyPairFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string bodyA = 1;
  void clear_bodya();
  static const int kBodyAFieldNumber = 1;
  const ::std::string& bodya() const;
  void set_bodya(const ::std::string& value);
  #if LANG_CXX11
  void set_bodya(::std::string&& value);
  #endif
  void set_bodya(const char* value);
  void set_bodya(const char* value, size_t size);
  ::std::string* mutable_bodya();
  ::std::string* release_bodya();
  void set_allocated_bodya(::std::string* bodya);

  // string bodyB = 2;
  void clear_bodyb();
  static const int kBodyBFieldNumber = 2;
  const ::std::string& bodyb() const;
  void set_bodyb(const ::std::string& value);
  #if LANG_CXX11
  void set_bodyb(::std::string&& value);
  #endif
  void set_bodyb(const char* value);
  void set_bodyb(const char* value, size_t size);
  ::std::string* mutable_bodyb();
  ::std::string* release_bodyb();
  void set_allocated_bodyb(::std::string* bodyb);

  // @@protoc_insertion_point(class_scope:CreateDOM.BodyPairFilter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bodya_;
  ::google::protobuf::internal::ArenaStringPtr bodyb_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BodyPairFilters : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.BodyPairFilters) */ {
 public:
  BodyPairFilters();
  virtual ~BodyPairFilters();

  BodyPairFilters(const BodyPairFilters& from);

  inline BodyPairFilters& operator=(const BodyPairFilters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BodyPairFilters(BodyPairFilters&& from) noexcept
    : BodyPairFilters() {
    *this = ::std::move(from);
  }

  inline BodyPairFilters& operator=(BodyPairFilters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BodyPairFilters& default_instance();

  static inline const BodyPairFilters* internal_default_instance() {
    return reinterpret_cast<const BodyPairFilters*>(
               &_BodyPairFilters_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(BodyPairFilters* other);
  friend void swap(BodyPairFilters& a, BodyPairFilters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BodyPairFilters* New() const PROTOBUF_FINAL { return New(NULL); }

  BodyPairFilters* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BodyPairFilters& from);
  void MergeFrom(const BodyPairFilters& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BodyPairFilters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CreateDOM.BodyPairFilter bodyPairs = 1;
  int bodypairs_size() const;
  void clear_bodypairs();
  static const int kBodyPairsFieldNumber = 1;
  const ::CreateDOM::BodyPairFilter& bodypairs(int index) const;
  ::CreateDOM::BodyPairFilter* mutable_bodypairs(int index);
  ::CreateDOM::BodyPairFilter* add_bodypairs();
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::BodyPairFilter >*
      mutable_bodypairs();
  const ::google::protobuf::RepeatedPtrField< ::CreateDOM::BodyPairFilter >&
      bodypairs() const;

  // @@protoc_insertion_point(class_scope:CreateDOM.BodyPairFilters)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::BodyPairFilter > bodypairs_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InstanceCollection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.InstanceCollection) */ {
 public:
  InstanceCollection();
  virtual ~InstanceCollection();

  InstanceCollection(const InstanceCollection& from);

  inline InstanceCollection& operator=(const InstanceCollection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InstanceCollection(InstanceCollection&& from) noexcept
    : InstanceCollection() {
    *this = ::std::move(from);
  }

  inline InstanceCollection& operator=(InstanceCollection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceCollection& default_instance();

  static inline const InstanceCollection* internal_default_instance() {
    return reinterpret_cast<const InstanceCollection*>(
               &_InstanceCollection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(InstanceCollection* other);
  friend void swap(InstanceCollection& a, InstanceCollection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InstanceCollection* New() const PROTOBUF_FINAL { return New(NULL); }

  InstanceCollection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InstanceCollection& from);
  void MergeFrom(const InstanceCollection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InstanceCollection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string collection = 1;
  void clear_collection();
  static const int kCollectionFieldNumber = 1;
  const ::std::string& collection() const;
  void set_collection(const ::std::string& value);
  #if LANG_CXX11
  void set_collection(::std::string&& value);
  #endif
  void set_collection(const char* value);
  void set_collection(const char* value, size_t size);
  ::std::string* mutable_collection();
  ::std::string* release_collection();
  void set_allocated_collection(::std::string* collection);

  // .CreateDOM.Pose pose = 2;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 2;
  const ::CreateDOM::Pose& pose() const;
  ::CreateDOM::Pose* mutable_pose();
  ::CreateDOM::Pose* release_pose();
  void set_allocated_pose(::CreateDOM::Pose* pose);

  // .CreateDOM.Vec3 scale = 3;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 3;
  const ::CreateDOM::Vec3& scale() const;
  ::CreateDOM::Vec3* mutable_scale();
  ::CreateDOM::Vec3* release_scale();
  void set_allocated_scale(::CreateDOM::Vec3* scale);

  // @@protoc_insertion_point(class_scope:CreateDOM.InstanceCollection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr collection_;
  ::CreateDOM::Pose* pose_;
  ::CreateDOM::Vec3* scale_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Collection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.Collection) */ {
 public:
  Collection();
  virtual ~Collection();

  Collection(const Collection& from);

  inline Collection& operator=(const Collection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Collection(Collection&& from) noexcept
    : Collection() {
    *this = ::std::move(from);
  }

  inline Collection& operator=(Collection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Collection& default_instance();

  static inline const Collection* internal_default_instance() {
    return reinterpret_cast<const Collection*>(
               &_Collection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(Collection* other);
  friend void swap(Collection& a, Collection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Collection* New() const PROTOBUF_FINAL { return New(NULL); }

  Collection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Collection& from);
  void MergeFrom(const Collection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Collection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CreateDOM.Node nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  const ::CreateDOM::Node& nodes(int index) const;
  ::CreateDOM::Node* mutable_nodes(int index);
  ::CreateDOM::Node* add_nodes();
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node >*
      mutable_nodes();
  const ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:CreateDOM.Collection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node > nodes_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scene : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.Scene) */ {
 public:
  Scene();
  virtual ~Scene();

  Scene(const Scene& from);

  inline Scene& operator=(const Scene& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scene(Scene&& from) noexcept
    : Scene() {
    *this = ::std::move(from);
  }

  inline Scene& operator=(Scene&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scene& default_instance();

  static inline const Scene* internal_default_instance() {
    return reinterpret_cast<const Scene*>(
               &_Scene_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(Scene* other);
  friend void swap(Scene& a, Scene& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scene* New() const PROTOBUF_FINAL { return New(NULL); }

  Scene* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Scene& from);
  void MergeFrom(const Scene& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Scene* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CreateDOM.Node nodes = 2;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 2;
  const ::CreateDOM::Node& nodes(int index) const;
  ::CreateDOM::Node* mutable_nodes(int index);
  ::CreateDOM::Node* add_nodes();
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node >*
      mutable_nodes();
  const ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node >&
      nodes() const;

  // .CreateDOM.Vec3 gravity = 1;
  bool has_gravity() const;
  void clear_gravity();
  static const int kGravityFieldNumber = 1;
  const ::CreateDOM::Vec3& gravity() const;
  ::CreateDOM::Vec3* mutable_gravity();
  ::CreateDOM::Vec3* release_gravity();
  void set_allocated_gravity(::CreateDOM::Vec3* gravity);

  // @@protoc_insertion_point(class_scope:CreateDOM.Scene)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node > nodes_;
  ::CreateDOM::Vec3* gravity_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PhysicsDOM : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateDOM.PhysicsDOM) */ {
 public:
  PhysicsDOM();
  virtual ~PhysicsDOM();

  PhysicsDOM(const PhysicsDOM& from);

  inline PhysicsDOM& operator=(const PhysicsDOM& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PhysicsDOM(PhysicsDOM&& from) noexcept
    : PhysicsDOM() {
    *this = ::std::move(from);
  }

  inline PhysicsDOM& operator=(PhysicsDOM&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PhysicsDOM& default_instance();

  static inline const PhysicsDOM* internal_default_instance() {
    return reinterpret_cast<const PhysicsDOM*>(
               &_PhysicsDOM_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(PhysicsDOM* other);
  friend void swap(PhysicsDOM& a, PhysicsDOM& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PhysicsDOM* New() const PROTOBUF_FINAL { return New(NULL); }

  PhysicsDOM* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PhysicsDOM& from);
  void MergeFrom(const PhysicsDOM& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PhysicsDOM* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CreateDOM.Node collections = 1;
  int collections_size() const;
  void clear_collections();
  static const int kCollectionsFieldNumber = 1;
  const ::CreateDOM::Node& collections(int index) const;
  ::CreateDOM::Node* mutable_collections(int index);
  ::CreateDOM::Node* add_collections();
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node >*
      mutable_collections();
  const ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node >&
      collections() const;

  // repeated .CreateDOM.Node scenes = 2;
  int scenes_size() const;
  void clear_scenes();
  static const int kScenesFieldNumber = 2;
  const ::CreateDOM::Node& scenes(int index) const;
  ::CreateDOM::Node* mutable_scenes(int index);
  ::CreateDOM::Node* add_scenes();
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node >*
      mutable_scenes();
  const ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node >&
      scenes() const;

  // @@protoc_insertion_point(class_scope:CreateDOM.PhysicsDOM)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node > collections_;
  ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node > scenes_;
  mutable int _cached_size_;
  friend struct protobuf_PhysicsDOM_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vec3

// float x = 1;
inline void Vec3::clear_x() {
  x_ = 0;
}
inline float Vec3::x() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Vec3.x)
  return x_;
}
inline void Vec3::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.Vec3.x)
}

// float y = 2;
inline void Vec3::clear_y() {
  y_ = 0;
}
inline float Vec3::y() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Vec3.y)
  return y_;
}
inline void Vec3::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.Vec3.y)
}

// float z = 3;
inline void Vec3::clear_z() {
  z_ = 0;
}
inline float Vec3::z() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Vec3.z)
  return z_;
}
inline void Vec3::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.Vec3.z)
}

// -------------------------------------------------------------------

// Quat

// float x = 1;
inline void Quat::clear_x() {
  x_ = 0;
}
inline float Quat::x() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Quat.x)
  return x_;
}
inline void Quat::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.Quat.x)
}

// float y = 2;
inline void Quat::clear_y() {
  y_ = 0;
}
inline float Quat::y() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Quat.y)
  return y_;
}
inline void Quat::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.Quat.y)
}

// float z = 3;
inline void Quat::clear_z() {
  z_ = 0;
}
inline float Quat::z() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Quat.z)
  return z_;
}
inline void Quat::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.Quat.z)
}

// float w = 4;
inline void Quat::clear_w() {
  w_ = 0;
}
inline float Quat::w() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Quat.w)
  return w_;
}
inline void Quat::set_w(float value) {
  
  w_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.Quat.w)
}

// -------------------------------------------------------------------

// Plane

// .CreateDOM.Vec3 n = 1;
inline bool Plane::has_n() const {
  return this != internal_default_instance() && n_ != NULL;
}
inline void Plane::clear_n() {
  if (GetArenaNoVirtual() == NULL && n_ != NULL) delete n_;
  n_ = NULL;
}
inline const ::CreateDOM::Vec3& Plane::n() const {
  const ::CreateDOM::Vec3* p = n_;
  // @@protoc_insertion_point(field_get:CreateDOM.Plane.n)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Vec3*>(
      &::CreateDOM::_Vec3_default_instance_);
}
inline ::CreateDOM::Vec3* Plane::mutable_n() {
  
  if (n_ == NULL) {
    n_ = new ::CreateDOM::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Plane.n)
  return n_;
}
inline ::CreateDOM::Vec3* Plane::release_n() {
  // @@protoc_insertion_point(field_release:CreateDOM.Plane.n)
  
  ::CreateDOM::Vec3* temp = n_;
  n_ = NULL;
  return temp;
}
inline void Plane::set_allocated_n(::CreateDOM::Vec3* n) {
  delete n_;
  n_ = n;
  if (n) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Plane.n)
}

// float d = 2;
inline void Plane::clear_d() {
  d_ = 0;
}
inline float Plane::d() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Plane.d)
  return d_;
}
inline void Plane::set_d(float value) {
  
  d_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.Plane.d)
}

// -------------------------------------------------------------------

// Pose

// .CreateDOM.Quat q = 1;
inline bool Pose::has_q() const {
  return this != internal_default_instance() && q_ != NULL;
}
inline void Pose::clear_q() {
  if (GetArenaNoVirtual() == NULL && q_ != NULL) delete q_;
  q_ = NULL;
}
inline const ::CreateDOM::Quat& Pose::q() const {
  const ::CreateDOM::Quat* p = q_;
  // @@protoc_insertion_point(field_get:CreateDOM.Pose.q)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Quat*>(
      &::CreateDOM::_Quat_default_instance_);
}
inline ::CreateDOM::Quat* Pose::mutable_q() {
  
  if (q_ == NULL) {
    q_ = new ::CreateDOM::Quat;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Pose.q)
  return q_;
}
inline ::CreateDOM::Quat* Pose::release_q() {
  // @@protoc_insertion_point(field_release:CreateDOM.Pose.q)
  
  ::CreateDOM::Quat* temp = q_;
  q_ = NULL;
  return temp;
}
inline void Pose::set_allocated_q(::CreateDOM::Quat* q) {
  delete q_;
  q_ = q;
  if (q) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Pose.q)
}

// .CreateDOM.Vec3 p = 2;
inline bool Pose::has_p() const {
  return this != internal_default_instance() && p_ != NULL;
}
inline void Pose::clear_p() {
  if (GetArenaNoVirtual() == NULL && p_ != NULL) delete p_;
  p_ = NULL;
}
inline const ::CreateDOM::Vec3& Pose::p() const {
  const ::CreateDOM::Vec3* p = p_;
  // @@protoc_insertion_point(field_get:CreateDOM.Pose.p)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Vec3*>(
      &::CreateDOM::_Vec3_default_instance_);
}
inline ::CreateDOM::Vec3* Pose::mutable_p() {
  
  if (p_ == NULL) {
    p_ = new ::CreateDOM::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Pose.p)
  return p_;
}
inline ::CreateDOM::Vec3* Pose::release_p() {
  // @@protoc_insertion_point(field_release:CreateDOM.Pose.p)
  
  ::CreateDOM::Vec3* temp = p_;
  p_ = NULL;
  return temp;
}
inline void Pose::set_allocated_p(::CreateDOM::Vec3* p) {
  delete p_;
  p_ = p;
  if (p) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Pose.p)
}

// -------------------------------------------------------------------

// Bounds3

// .CreateDOM.Vec3 bmin = 1;
inline bool Bounds3::has_bmin() const {
  return this != internal_default_instance() && bmin_ != NULL;
}
inline void Bounds3::clear_bmin() {
  if (GetArenaNoVirtual() == NULL && bmin_ != NULL) delete bmin_;
  bmin_ = NULL;
}
inline const ::CreateDOM::Vec3& Bounds3::bmin() const {
  const ::CreateDOM::Vec3* p = bmin_;
  // @@protoc_insertion_point(field_get:CreateDOM.Bounds3.bmin)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Vec3*>(
      &::CreateDOM::_Vec3_default_instance_);
}
inline ::CreateDOM::Vec3* Bounds3::mutable_bmin() {
  
  if (bmin_ == NULL) {
    bmin_ = new ::CreateDOM::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Bounds3.bmin)
  return bmin_;
}
inline ::CreateDOM::Vec3* Bounds3::release_bmin() {
  // @@protoc_insertion_point(field_release:CreateDOM.Bounds3.bmin)
  
  ::CreateDOM::Vec3* temp = bmin_;
  bmin_ = NULL;
  return temp;
}
inline void Bounds3::set_allocated_bmin(::CreateDOM::Vec3* bmin) {
  delete bmin_;
  bmin_ = bmin;
  if (bmin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Bounds3.bmin)
}

// .CreateDOM.Vec3 bmax = 2;
inline bool Bounds3::has_bmax() const {
  return this != internal_default_instance() && bmax_ != NULL;
}
inline void Bounds3::clear_bmax() {
  if (GetArenaNoVirtual() == NULL && bmax_ != NULL) delete bmax_;
  bmax_ = NULL;
}
inline const ::CreateDOM::Vec3& Bounds3::bmax() const {
  const ::CreateDOM::Vec3* p = bmax_;
  // @@protoc_insertion_point(field_get:CreateDOM.Bounds3.bmax)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Vec3*>(
      &::CreateDOM::_Vec3_default_instance_);
}
inline ::CreateDOM::Vec3* Bounds3::mutable_bmax() {
  
  if (bmax_ == NULL) {
    bmax_ = new ::CreateDOM::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Bounds3.bmax)
  return bmax_;
}
inline ::CreateDOM::Vec3* Bounds3::release_bmax() {
  // @@protoc_insertion_point(field_release:CreateDOM.Bounds3.bmax)
  
  ::CreateDOM::Vec3* temp = bmax_;
  bmax_ = NULL;
  return temp;
}
inline void Bounds3::set_allocated_bmax(::CreateDOM::Vec3* bmax) {
  delete bmax_;
  bmax_ = bmax;
  if (bmax) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Bounds3.bmax)
}

// -------------------------------------------------------------------

// VisualBinding

// string visualName = 1;
inline void VisualBinding::clear_visualname() {
  visualname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VisualBinding::visualname() const {
  // @@protoc_insertion_point(field_get:CreateDOM.VisualBinding.visualName)
  return visualname_.GetNoArena();
}
inline void VisualBinding::set_visualname(const ::std::string& value) {
  
  visualname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateDOM.VisualBinding.visualName)
}
#if LANG_CXX11
inline void VisualBinding::set_visualname(::std::string&& value) {
  
  visualname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateDOM.VisualBinding.visualName)
}
#endif
inline void VisualBinding::set_visualname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  visualname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateDOM.VisualBinding.visualName)
}
inline void VisualBinding::set_visualname(const char* value, size_t size) {
  
  visualname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateDOM.VisualBinding.visualName)
}
inline ::std::string* VisualBinding::mutable_visualname() {
  
  // @@protoc_insertion_point(field_mutable:CreateDOM.VisualBinding.visualName)
  return visualname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VisualBinding::release_visualname() {
  // @@protoc_insertion_point(field_release:CreateDOM.VisualBinding.visualName)
  
  return visualname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VisualBinding::set_allocated_visualname(::std::string* visualname) {
  if (visualname != NULL) {
    
  } else {
    
  }
  visualname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), visualname);
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.VisualBinding.visualName)
}

// .CreateDOM.Pose localPose = 2;
inline bool VisualBinding::has_localpose() const {
  return this != internal_default_instance() && localpose_ != NULL;
}
inline void VisualBinding::clear_localpose() {
  if (GetArenaNoVirtual() == NULL && localpose_ != NULL) delete localpose_;
  localpose_ = NULL;
}
inline const ::CreateDOM::Pose& VisualBinding::localpose() const {
  const ::CreateDOM::Pose* p = localpose_;
  // @@protoc_insertion_point(field_get:CreateDOM.VisualBinding.localPose)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Pose*>(
      &::CreateDOM::_Pose_default_instance_);
}
inline ::CreateDOM::Pose* VisualBinding::mutable_localpose() {
  
  if (localpose_ == NULL) {
    localpose_ = new ::CreateDOM::Pose;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.VisualBinding.localPose)
  return localpose_;
}
inline ::CreateDOM::Pose* VisualBinding::release_localpose() {
  // @@protoc_insertion_point(field_release:CreateDOM.VisualBinding.localPose)
  
  ::CreateDOM::Pose* temp = localpose_;
  localpose_ = NULL;
  return temp;
}
inline void VisualBinding::set_allocated_localpose(::CreateDOM::Pose* localpose) {
  delete localpose_;
  localpose_ = localpose;
  if (localpose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.VisualBinding.localPose)
}

// .CreateDOM.Vec3 localScale = 3;
inline bool VisualBinding::has_localscale() const {
  return this != internal_default_instance() && localscale_ != NULL;
}
inline void VisualBinding::clear_localscale() {
  if (GetArenaNoVirtual() == NULL && localscale_ != NULL) delete localscale_;
  localscale_ = NULL;
}
inline const ::CreateDOM::Vec3& VisualBinding::localscale() const {
  const ::CreateDOM::Vec3* p = localscale_;
  // @@protoc_insertion_point(field_get:CreateDOM.VisualBinding.localScale)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Vec3*>(
      &::CreateDOM::_Vec3_default_instance_);
}
inline ::CreateDOM::Vec3* VisualBinding::mutable_localscale() {
  
  if (localscale_ == NULL) {
    localscale_ = new ::CreateDOM::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.VisualBinding.localScale)
  return localscale_;
}
inline ::CreateDOM::Vec3* VisualBinding::release_localscale() {
  // @@protoc_insertion_point(field_release:CreateDOM.VisualBinding.localScale)
  
  ::CreateDOM::Vec3* temp = localscale_;
  localscale_ = NULL;
  return temp;
}
inline void VisualBinding::set_allocated_localscale(::CreateDOM::Vec3* localscale) {
  delete localscale_;
  localscale_ = localscale;
  if (localscale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.VisualBinding.localScale)
}

// -------------------------------------------------------------------

// KeyValuePair

// string key = 1;
inline void KeyValuePair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValuePair::key() const {
  // @@protoc_insertion_point(field_get:CreateDOM.KeyValuePair.key)
  return key_.GetNoArena();
}
inline void KeyValuePair::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateDOM.KeyValuePair.key)
}
#if LANG_CXX11
inline void KeyValuePair::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateDOM.KeyValuePair.key)
}
#endif
inline void KeyValuePair::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateDOM.KeyValuePair.key)
}
inline void KeyValuePair::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateDOM.KeyValuePair.key)
}
inline ::std::string* KeyValuePair::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:CreateDOM.KeyValuePair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValuePair::release_key() {
  // @@protoc_insertion_point(field_release:CreateDOM.KeyValuePair.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValuePair::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.KeyValuePair.key)
}

// string value = 2;
inline void KeyValuePair::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValuePair::value() const {
  // @@protoc_insertion_point(field_get:CreateDOM.KeyValuePair.value)
  return value_.GetNoArena();
}
inline void KeyValuePair::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateDOM.KeyValuePair.value)
}
#if LANG_CXX11
inline void KeyValuePair::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateDOM.KeyValuePair.value)
}
#endif
inline void KeyValuePair::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateDOM.KeyValuePair.value)
}
inline void KeyValuePair::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateDOM.KeyValuePair.value)
}
inline ::std::string* KeyValuePair::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:CreateDOM.KeyValuePair.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValuePair::release_value() {
  // @@protoc_insertion_point(field_release:CreateDOM.KeyValuePair.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValuePair::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.KeyValuePair.value)
}

// -------------------------------------------------------------------

// AdditionalProperties

// string category = 1;
inline void AdditionalProperties::clear_category() {
  category_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AdditionalProperties::category() const {
  // @@protoc_insertion_point(field_get:CreateDOM.AdditionalProperties.category)
  return category_.GetNoArena();
}
inline void AdditionalProperties::set_category(const ::std::string& value) {
  
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateDOM.AdditionalProperties.category)
}
#if LANG_CXX11
inline void AdditionalProperties::set_category(::std::string&& value) {
  
  category_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateDOM.AdditionalProperties.category)
}
#endif
inline void AdditionalProperties::set_category(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateDOM.AdditionalProperties.category)
}
inline void AdditionalProperties::set_category(const char* value, size_t size) {
  
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateDOM.AdditionalProperties.category)
}
inline ::std::string* AdditionalProperties::mutable_category() {
  
  // @@protoc_insertion_point(field_mutable:CreateDOM.AdditionalProperties.category)
  return category_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AdditionalProperties::release_category() {
  // @@protoc_insertion_point(field_release:CreateDOM.AdditionalProperties.category)
  
  return category_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AdditionalProperties::set_allocated_category(::std::string* category) {
  if (category != NULL) {
    
  } else {
    
  }
  category_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), category);
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.AdditionalProperties.category)
}

// repeated .CreateDOM.KeyValuePair keyValuePairs = 2;
inline int AdditionalProperties::keyvaluepairs_size() const {
  return keyvaluepairs_.size();
}
inline void AdditionalProperties::clear_keyvaluepairs() {
  keyvaluepairs_.Clear();
}
inline const ::CreateDOM::KeyValuePair& AdditionalProperties::keyvaluepairs(int index) const {
  // @@protoc_insertion_point(field_get:CreateDOM.AdditionalProperties.keyValuePairs)
  return keyvaluepairs_.Get(index);
}
inline ::CreateDOM::KeyValuePair* AdditionalProperties::mutable_keyvaluepairs(int index) {
  // @@protoc_insertion_point(field_mutable:CreateDOM.AdditionalProperties.keyValuePairs)
  return keyvaluepairs_.Mutable(index);
}
inline ::CreateDOM::KeyValuePair* AdditionalProperties::add_keyvaluepairs() {
  // @@protoc_insertion_point(field_add:CreateDOM.AdditionalProperties.keyValuePairs)
  return keyvaluepairs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CreateDOM::KeyValuePair >*
AdditionalProperties::mutable_keyvaluepairs() {
  // @@protoc_insertion_point(field_mutable_list:CreateDOM.AdditionalProperties.keyValuePairs)
  return &keyvaluepairs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CreateDOM::KeyValuePair >&
AdditionalProperties::keyvaluepairs() const {
  // @@protoc_insertion_point(field_list:CreateDOM.AdditionalProperties.keyValuePairs)
  return keyvaluepairs_;
}

// -------------------------------------------------------------------

// Node

// string id = 1;
inline void Node::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::id() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Node.id)
  return id_.GetNoArena();
}
inline void Node::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateDOM.Node.id)
}
#if LANG_CXX11
inline void Node::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateDOM.Node.id)
}
#endif
inline void Node::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateDOM.Node.id)
}
inline void Node::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateDOM.Node.id)
}
inline ::std::string* Node::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:CreateDOM.Node.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_id() {
  // @@protoc_insertion_point(field_release:CreateDOM.Node.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Node.id)
}

// string name = 2;
inline void Node::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::name() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Node.name)
  return name_.GetNoArena();
}
inline void Node::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateDOM.Node.name)
}
#if LANG_CXX11
inline void Node::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateDOM.Node.name)
}
#endif
inline void Node::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateDOM.Node.name)
}
inline void Node::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateDOM.Node.name)
}
inline ::std::string* Node::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:CreateDOM.Node.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_name() {
  // @@protoc_insertion_point(field_release:CreateDOM.Node.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Node.name)
}

// .CreateDOM.NodeType type = 3;
inline void Node::clear_type() {
  type_ = 0;
}
inline ::CreateDOM::NodeType Node::type() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Node.type)
  return static_cast< ::CreateDOM::NodeType >(type_);
}
inline void Node::set_type(::CreateDOM::NodeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.Node.type)
}

// .CreateDOM.VisualBinding visual = 4;
inline bool Node::has_visual() const {
  return this != internal_default_instance() && visual_ != NULL;
}
inline void Node::clear_visual() {
  if (GetArenaNoVirtual() == NULL && visual_ != NULL) delete visual_;
  visual_ = NULL;
}
inline const ::CreateDOM::VisualBinding& Node::visual() const {
  const ::CreateDOM::VisualBinding* p = visual_;
  // @@protoc_insertion_point(field_get:CreateDOM.Node.visual)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::VisualBinding*>(
      &::CreateDOM::_VisualBinding_default_instance_);
}
inline ::CreateDOM::VisualBinding* Node::mutable_visual() {
  
  if (visual_ == NULL) {
    visual_ = new ::CreateDOM::VisualBinding;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Node.visual)
  return visual_;
}
inline ::CreateDOM::VisualBinding* Node::release_visual() {
  // @@protoc_insertion_point(field_release:CreateDOM.Node.visual)
  
  ::CreateDOM::VisualBinding* temp = visual_;
  visual_ = NULL;
  return temp;
}
inline void Node::set_allocated_visual(::CreateDOM::VisualBinding* visual) {
  delete visual_;
  visual_ = visual;
  if (visual) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Node.visual)
}

// repeated .CreateDOM.AdditionalProperties additionalProperties = 5;
inline int Node::additionalproperties_size() const {
  return additionalproperties_.size();
}
inline void Node::clear_additionalproperties() {
  additionalproperties_.Clear();
}
inline const ::CreateDOM::AdditionalProperties& Node::additionalproperties(int index) const {
  // @@protoc_insertion_point(field_get:CreateDOM.Node.additionalProperties)
  return additionalproperties_.Get(index);
}
inline ::CreateDOM::AdditionalProperties* Node::mutable_additionalproperties(int index) {
  // @@protoc_insertion_point(field_mutable:CreateDOM.Node.additionalProperties)
  return additionalproperties_.Mutable(index);
}
inline ::CreateDOM::AdditionalProperties* Node::add_additionalproperties() {
  // @@protoc_insertion_point(field_add:CreateDOM.Node.additionalProperties)
  return additionalproperties_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CreateDOM::AdditionalProperties >*
Node::mutable_additionalproperties() {
  // @@protoc_insertion_point(field_mutable_list:CreateDOM.Node.additionalProperties)
  return &additionalproperties_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CreateDOM::AdditionalProperties >&
Node::additionalproperties() const {
  // @@protoc_insertion_point(field_list:CreateDOM.Node.additionalProperties)
  return additionalproperties_;
}

// .CreateDOM.PhysicsMaterial physicsMaterial = 6;
inline bool Node::has_physicsmaterial() const {
  return subtype_case() == kPhysicsMaterial;
}
inline void Node::set_has_physicsmaterial() {
  _oneof_case_[0] = kPhysicsMaterial;
}
inline void Node::clear_physicsmaterial() {
  if (has_physicsmaterial()) {
    delete subtype_.physicsmaterial_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::PhysicsMaterial& Node::physicsmaterial() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Node.physicsMaterial)
  return has_physicsmaterial()
      ? *subtype_.physicsmaterial_
      : ::CreateDOM::PhysicsMaterial::default_instance();
}
inline ::CreateDOM::PhysicsMaterial* Node::mutable_physicsmaterial() {
  if (!has_physicsmaterial()) {
    clear_subtype();
    set_has_physicsmaterial();
    subtype_.physicsmaterial_ = new ::CreateDOM::PhysicsMaterial;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Node.physicsMaterial)
  return subtype_.physicsmaterial_;
}
inline ::CreateDOM::PhysicsMaterial* Node::release_physicsmaterial() {
  // @@protoc_insertion_point(field_release:CreateDOM.Node.physicsMaterial)
  if (has_physicsmaterial()) {
    clear_has_subtype();
    ::CreateDOM::PhysicsMaterial* temp = subtype_.physicsmaterial_;
    subtype_.physicsmaterial_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Node::set_allocated_physicsmaterial(::CreateDOM::PhysicsMaterial* physicsmaterial) {
  clear_subtype();
  if (physicsmaterial) {
    set_has_physicsmaterial();
    subtype_.physicsmaterial_ = physicsmaterial;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Node.physicsMaterial)
}

// .CreateDOM.ConvexHull convexHull = 7;
inline bool Node::has_convexhull() const {
  return subtype_case() == kConvexHull;
}
inline void Node::set_has_convexhull() {
  _oneof_case_[0] = kConvexHull;
}
inline void Node::clear_convexhull() {
  if (has_convexhull()) {
    delete subtype_.convexhull_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::ConvexHull& Node::convexhull() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Node.convexHull)
  return has_convexhull()
      ? *subtype_.convexhull_
      : ::CreateDOM::ConvexHull::default_instance();
}
inline ::CreateDOM::ConvexHull* Node::mutable_convexhull() {
  if (!has_convexhull()) {
    clear_subtype();
    set_has_convexhull();
    subtype_.convexhull_ = new ::CreateDOM::ConvexHull;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Node.convexHull)
  return subtype_.convexhull_;
}
inline ::CreateDOM::ConvexHull* Node::release_convexhull() {
  // @@protoc_insertion_point(field_release:CreateDOM.Node.convexHull)
  if (has_convexhull()) {
    clear_has_subtype();
    ::CreateDOM::ConvexHull* temp = subtype_.convexhull_;
    subtype_.convexhull_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Node::set_allocated_convexhull(::CreateDOM::ConvexHull* convexhull) {
  clear_subtype();
  if (convexhull) {
    set_has_convexhull();
    subtype_.convexhull_ = convexhull;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Node.convexHull)
}

// .CreateDOM.TriangleMesh triangleMesh = 8;
inline bool Node::has_trianglemesh() const {
  return subtype_case() == kTriangleMesh;
}
inline void Node::set_has_trianglemesh() {
  _oneof_case_[0] = kTriangleMesh;
}
inline void Node::clear_trianglemesh() {
  if (has_trianglemesh()) {
    delete subtype_.trianglemesh_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::TriangleMesh& Node::trianglemesh() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Node.triangleMesh)
  return has_trianglemesh()
      ? *subtype_.trianglemesh_
      : ::CreateDOM::TriangleMesh::default_instance();
}
inline ::CreateDOM::TriangleMesh* Node::mutable_trianglemesh() {
  if (!has_trianglemesh()) {
    clear_subtype();
    set_has_trianglemesh();
    subtype_.trianglemesh_ = new ::CreateDOM::TriangleMesh;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Node.triangleMesh)
  return subtype_.trianglemesh_;
}
inline ::CreateDOM::TriangleMesh* Node::release_trianglemesh() {
  // @@protoc_insertion_point(field_release:CreateDOM.Node.triangleMesh)
  if (has_trianglemesh()) {
    clear_has_subtype();
    ::CreateDOM::TriangleMesh* temp = subtype_.trianglemesh_;
    subtype_.trianglemesh_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Node::set_allocated_trianglemesh(::CreateDOM::TriangleMesh* trianglemesh) {
  clear_subtype();
  if (trianglemesh) {
    set_has_trianglemesh();
    subtype_.trianglemesh_ = trianglemesh;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Node.triangleMesh)
}

// .CreateDOM.HeightField heightField = 9;
inline bool Node::has_heightfield() const {
  return subtype_case() == kHeightField;
}
inline void Node::set_has_heightfield() {
  _oneof_case_[0] = kHeightField;
}
inline void Node::clear_heightfield() {
  if (has_heightfield()) {
    delete subtype_.heightfield_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::HeightField& Node::heightfield() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Node.heightField)
  return has_heightfield()
      ? *subtype_.heightfield_
      : ::CreateDOM::HeightField::default_instance();
}
inline ::CreateDOM::HeightField* Node::mutable_heightfield() {
  if (!has_heightfield()) {
    clear_subtype();
    set_has_heightfield();
    subtype_.heightfield_ = new ::CreateDOM::HeightField;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Node.heightField)
  return subtype_.heightfield_;
}
inline ::CreateDOM::HeightField* Node::release_heightfield() {
  // @@protoc_insertion_point(field_release:CreateDOM.Node.heightField)
  if (has_heightfield()) {
    clear_has_subtype();
    ::CreateDOM::HeightField* temp = subtype_.heightfield_;
    subtype_.heightfield_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Node::set_allocated_heightfield(::CreateDOM::HeightField* heightfield) {
  clear_subtype();
  if (heightfield) {
    set_has_heightfield();
    subtype_.heightfield_ = heightfield;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Node.heightField)
}

// .CreateDOM.RigidBody rigidBody = 10;
inline bool Node::has_rigidbody() const {
  return subtype_case() == kRigidBody;
}
inline void Node::set_has_rigidbody() {
  _oneof_case_[0] = kRigidBody;
}
inline void Node::clear_rigidbody() {
  if (has_rigidbody()) {
    delete subtype_.rigidbody_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::RigidBody& Node::rigidbody() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Node.rigidBody)
  return has_rigidbody()
      ? *subtype_.rigidbody_
      : ::CreateDOM::RigidBody::default_instance();
}
inline ::CreateDOM::RigidBody* Node::mutable_rigidbody() {
  if (!has_rigidbody()) {
    clear_subtype();
    set_has_rigidbody();
    subtype_.rigidbody_ = new ::CreateDOM::RigidBody;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Node.rigidBody)
  return subtype_.rigidbody_;
}
inline ::CreateDOM::RigidBody* Node::release_rigidbody() {
  // @@protoc_insertion_point(field_release:CreateDOM.Node.rigidBody)
  if (has_rigidbody()) {
    clear_has_subtype();
    ::CreateDOM::RigidBody* temp = subtype_.rigidbody_;
    subtype_.rigidbody_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Node::set_allocated_rigidbody(::CreateDOM::RigidBody* rigidbody) {
  clear_subtype();
  if (rigidbody) {
    set_has_rigidbody();
    subtype_.rigidbody_ = rigidbody;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Node.rigidBody)
}

// .CreateDOM.Joint joint = 11;
inline bool Node::has_joint() const {
  return subtype_case() == kJoint;
}
inline void Node::set_has_joint() {
  _oneof_case_[0] = kJoint;
}
inline void Node::clear_joint() {
  if (has_joint()) {
    delete subtype_.joint_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::Joint& Node::joint() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Node.joint)
  return has_joint()
      ? *subtype_.joint_
      : ::CreateDOM::Joint::default_instance();
}
inline ::CreateDOM::Joint* Node::mutable_joint() {
  if (!has_joint()) {
    clear_subtype();
    set_has_joint();
    subtype_.joint_ = new ::CreateDOM::Joint;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Node.joint)
  return subtype_.joint_;
}
inline ::CreateDOM::Joint* Node::release_joint() {
  // @@protoc_insertion_point(field_release:CreateDOM.Node.joint)
  if (has_joint()) {
    clear_has_subtype();
    ::CreateDOM::Joint* temp = subtype_.joint_;
    subtype_.joint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Node::set_allocated_joint(::CreateDOM::Joint* joint) {
  clear_subtype();
  if (joint) {
    set_has_joint();
    subtype_.joint_ = joint;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Node.joint)
}

// .CreateDOM.BodyPairFilters bodyPairFilters = 12;
inline bool Node::has_bodypairfilters() const {
  return subtype_case() == kBodyPairFilters;
}
inline void Node::set_has_bodypairfilters() {
  _oneof_case_[0] = kBodyPairFilters;
}
inline void Node::clear_bodypairfilters() {
  if (has_bodypairfilters()) {
    delete subtype_.bodypairfilters_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::BodyPairFilters& Node::bodypairfilters() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Node.bodyPairFilters)
  return has_bodypairfilters()
      ? *subtype_.bodypairfilters_
      : ::CreateDOM::BodyPairFilters::default_instance();
}
inline ::CreateDOM::BodyPairFilters* Node::mutable_bodypairfilters() {
  if (!has_bodypairfilters()) {
    clear_subtype();
    set_has_bodypairfilters();
    subtype_.bodypairfilters_ = new ::CreateDOM::BodyPairFilters;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Node.bodyPairFilters)
  return subtype_.bodypairfilters_;
}
inline ::CreateDOM::BodyPairFilters* Node::release_bodypairfilters() {
  // @@protoc_insertion_point(field_release:CreateDOM.Node.bodyPairFilters)
  if (has_bodypairfilters()) {
    clear_has_subtype();
    ::CreateDOM::BodyPairFilters* temp = subtype_.bodypairfilters_;
    subtype_.bodypairfilters_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Node::set_allocated_bodypairfilters(::CreateDOM::BodyPairFilters* bodypairfilters) {
  clear_subtype();
  if (bodypairfilters) {
    set_has_bodypairfilters();
    subtype_.bodypairfilters_ = bodypairfilters;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Node.bodyPairFilters)
}

// .CreateDOM.InstanceCollection instanceCollection = 13;
inline bool Node::has_instancecollection() const {
  return subtype_case() == kInstanceCollection;
}
inline void Node::set_has_instancecollection() {
  _oneof_case_[0] = kInstanceCollection;
}
inline void Node::clear_instancecollection() {
  if (has_instancecollection()) {
    delete subtype_.instancecollection_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::InstanceCollection& Node::instancecollection() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Node.instanceCollection)
  return has_instancecollection()
      ? *subtype_.instancecollection_
      : ::CreateDOM::InstanceCollection::default_instance();
}
inline ::CreateDOM::InstanceCollection* Node::mutable_instancecollection() {
  if (!has_instancecollection()) {
    clear_subtype();
    set_has_instancecollection();
    subtype_.instancecollection_ = new ::CreateDOM::InstanceCollection;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Node.instanceCollection)
  return subtype_.instancecollection_;
}
inline ::CreateDOM::InstanceCollection* Node::release_instancecollection() {
  // @@protoc_insertion_point(field_release:CreateDOM.Node.instanceCollection)
  if (has_instancecollection()) {
    clear_has_subtype();
    ::CreateDOM::InstanceCollection* temp = subtype_.instancecollection_;
    subtype_.instancecollection_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Node::set_allocated_instancecollection(::CreateDOM::InstanceCollection* instancecollection) {
  clear_subtype();
  if (instancecollection) {
    set_has_instancecollection();
    subtype_.instancecollection_ = instancecollection;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Node.instanceCollection)
}

// .CreateDOM.Collection collection = 14;
inline bool Node::has_collection() const {
  return subtype_case() == kCollection;
}
inline void Node::set_has_collection() {
  _oneof_case_[0] = kCollection;
}
inline void Node::clear_collection() {
  if (has_collection()) {
    delete subtype_.collection_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::Collection& Node::collection() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Node.collection)
  return has_collection()
      ? *subtype_.collection_
      : ::CreateDOM::Collection::default_instance();
}
inline ::CreateDOM::Collection* Node::mutable_collection() {
  if (!has_collection()) {
    clear_subtype();
    set_has_collection();
    subtype_.collection_ = new ::CreateDOM::Collection;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Node.collection)
  return subtype_.collection_;
}
inline ::CreateDOM::Collection* Node::release_collection() {
  // @@protoc_insertion_point(field_release:CreateDOM.Node.collection)
  if (has_collection()) {
    clear_has_subtype();
    ::CreateDOM::Collection* temp = subtype_.collection_;
    subtype_.collection_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Node::set_allocated_collection(::CreateDOM::Collection* collection) {
  clear_subtype();
  if (collection) {
    set_has_collection();
    subtype_.collection_ = collection;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Node.collection)
}

// .CreateDOM.Scene scene = 15;
inline bool Node::has_scene() const {
  return subtype_case() == kScene;
}
inline void Node::set_has_scene() {
  _oneof_case_[0] = kScene;
}
inline void Node::clear_scene() {
  if (has_scene()) {
    delete subtype_.scene_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::Scene& Node::scene() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Node.scene)
  return has_scene()
      ? *subtype_.scene_
      : ::CreateDOM::Scene::default_instance();
}
inline ::CreateDOM::Scene* Node::mutable_scene() {
  if (!has_scene()) {
    clear_subtype();
    set_has_scene();
    subtype_.scene_ = new ::CreateDOM::Scene;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Node.scene)
  return subtype_.scene_;
}
inline ::CreateDOM::Scene* Node::release_scene() {
  // @@protoc_insertion_point(field_release:CreateDOM.Node.scene)
  if (has_scene()) {
    clear_has_subtype();
    ::CreateDOM::Scene* temp = subtype_.scene_;
    subtype_.scene_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Node::set_allocated_scene(::CreateDOM::Scene* scene) {
  clear_subtype();
  if (scene) {
    set_has_scene();
    subtype_.scene_ = scene;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Node.scene)
}

inline bool Node::has_subtype() const {
  return subtype_case() != SUBTYPE_NOT_SET;
}
inline void Node::clear_has_subtype() {
  _oneof_case_[0] = SUBTYPE_NOT_SET;
}
inline Node::SubtypeCase Node::subtype_case() const {
  return Node::SubtypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MeshScale

// .CreateDOM.Vec3 scale = 1;
inline bool MeshScale::has_scale() const {
  return this != internal_default_instance() && scale_ != NULL;
}
inline void MeshScale::clear_scale() {
  if (GetArenaNoVirtual() == NULL && scale_ != NULL) delete scale_;
  scale_ = NULL;
}
inline const ::CreateDOM::Vec3& MeshScale::scale() const {
  const ::CreateDOM::Vec3* p = scale_;
  // @@protoc_insertion_point(field_get:CreateDOM.MeshScale.scale)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Vec3*>(
      &::CreateDOM::_Vec3_default_instance_);
}
inline ::CreateDOM::Vec3* MeshScale::mutable_scale() {
  
  if (scale_ == NULL) {
    scale_ = new ::CreateDOM::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.MeshScale.scale)
  return scale_;
}
inline ::CreateDOM::Vec3* MeshScale::release_scale() {
  // @@protoc_insertion_point(field_release:CreateDOM.MeshScale.scale)
  
  ::CreateDOM::Vec3* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void MeshScale::set_allocated_scale(::CreateDOM::Vec3* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.MeshScale.scale)
}

// .CreateDOM.Quat rotation = 2;
inline bool MeshScale::has_rotation() const {
  return this != internal_default_instance() && rotation_ != NULL;
}
inline void MeshScale::clear_rotation() {
  if (GetArenaNoVirtual() == NULL && rotation_ != NULL) delete rotation_;
  rotation_ = NULL;
}
inline const ::CreateDOM::Quat& MeshScale::rotation() const {
  const ::CreateDOM::Quat* p = rotation_;
  // @@protoc_insertion_point(field_get:CreateDOM.MeshScale.rotation)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Quat*>(
      &::CreateDOM::_Quat_default_instance_);
}
inline ::CreateDOM::Quat* MeshScale::mutable_rotation() {
  
  if (rotation_ == NULL) {
    rotation_ = new ::CreateDOM::Quat;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.MeshScale.rotation)
  return rotation_;
}
inline ::CreateDOM::Quat* MeshScale::release_rotation() {
  // @@protoc_insertion_point(field_release:CreateDOM.MeshScale.rotation)
  
  ::CreateDOM::Quat* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline void MeshScale::set_allocated_rotation(::CreateDOM::Quat* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.MeshScale.rotation)
}

// -------------------------------------------------------------------

// PhysicsMaterial

// bool disableFriction = 1;
inline void PhysicsMaterial::clear_disablefriction() {
  disablefriction_ = false;
}
inline bool PhysicsMaterial::disablefriction() const {
  // @@protoc_insertion_point(field_get:CreateDOM.PhysicsMaterial.disableFriction)
  return disablefriction_;
}
inline void PhysicsMaterial::set_disablefriction(bool value) {
  
  disablefriction_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.PhysicsMaterial.disableFriction)
}

// bool disableStrongFriction = 2;
inline void PhysicsMaterial::clear_disablestrongfriction() {
  disablestrongfriction_ = false;
}
inline bool PhysicsMaterial::disablestrongfriction() const {
  // @@protoc_insertion_point(field_get:CreateDOM.PhysicsMaterial.disableStrongFriction)
  return disablestrongfriction_;
}
inline void PhysicsMaterial::set_disablestrongfriction(bool value) {
  
  disablestrongfriction_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.PhysicsMaterial.disableStrongFriction)
}

// float dynamicFriction = 3;
inline void PhysicsMaterial::clear_dynamicfriction() {
  dynamicfriction_ = 0;
}
inline float PhysicsMaterial::dynamicfriction() const {
  // @@protoc_insertion_point(field_get:CreateDOM.PhysicsMaterial.dynamicFriction)
  return dynamicfriction_;
}
inline void PhysicsMaterial::set_dynamicfriction(float value) {
  
  dynamicfriction_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.PhysicsMaterial.dynamicFriction)
}

// float staticFriction = 4;
inline void PhysicsMaterial::clear_staticfriction() {
  staticfriction_ = 0;
}
inline float PhysicsMaterial::staticfriction() const {
  // @@protoc_insertion_point(field_get:CreateDOM.PhysicsMaterial.staticFriction)
  return staticfriction_;
}
inline void PhysicsMaterial::set_staticfriction(float value) {
  
  staticfriction_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.PhysicsMaterial.staticFriction)
}

// float restitution = 5;
inline void PhysicsMaterial::clear_restitution() {
  restitution_ = 0;
}
inline float PhysicsMaterial::restitution() const {
  // @@protoc_insertion_point(field_get:CreateDOM.PhysicsMaterial.restitution)
  return restitution_;
}
inline void PhysicsMaterial::set_restitution(float value) {
  
  restitution_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.PhysicsMaterial.restitution)
}

// -------------------------------------------------------------------

// ConvexHull

// repeated .CreateDOM.Vec3 points = 1;
inline int ConvexHull::points_size() const {
  return points_.size();
}
inline void ConvexHull::clear_points() {
  points_.Clear();
}
inline const ::CreateDOM::Vec3& ConvexHull::points(int index) const {
  // @@protoc_insertion_point(field_get:CreateDOM.ConvexHull.points)
  return points_.Get(index);
}
inline ::CreateDOM::Vec3* ConvexHull::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:CreateDOM.ConvexHull.points)
  return points_.Mutable(index);
}
inline ::CreateDOM::Vec3* ConvexHull::add_points() {
  // @@protoc_insertion_point(field_add:CreateDOM.ConvexHull.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CreateDOM::Vec3 >*
ConvexHull::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:CreateDOM.ConvexHull.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CreateDOM::Vec3 >&
ConvexHull::points() const {
  // @@protoc_insertion_point(field_list:CreateDOM.ConvexHull.points)
  return points_;
}

// -------------------------------------------------------------------

// TriangleMesh

// repeated .CreateDOM.Vec3 points = 1;
inline int TriangleMesh::points_size() const {
  return points_.size();
}
inline void TriangleMesh::clear_points() {
  points_.Clear();
}
inline const ::CreateDOM::Vec3& TriangleMesh::points(int index) const {
  // @@protoc_insertion_point(field_get:CreateDOM.TriangleMesh.points)
  return points_.Get(index);
}
inline ::CreateDOM::Vec3* TriangleMesh::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:CreateDOM.TriangleMesh.points)
  return points_.Mutable(index);
}
inline ::CreateDOM::Vec3* TriangleMesh::add_points() {
  // @@protoc_insertion_point(field_add:CreateDOM.TriangleMesh.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CreateDOM::Vec3 >*
TriangleMesh::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:CreateDOM.TriangleMesh.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CreateDOM::Vec3 >&
TriangleMesh::points() const {
  // @@protoc_insertion_point(field_list:CreateDOM.TriangleMesh.points)
  return points_;
}

// repeated uint32 triangles = 2;
inline int TriangleMesh::triangles_size() const {
  return triangles_.size();
}
inline void TriangleMesh::clear_triangles() {
  triangles_.Clear();
}
inline ::google::protobuf::uint32 TriangleMesh::triangles(int index) const {
  // @@protoc_insertion_point(field_get:CreateDOM.TriangleMesh.triangles)
  return triangles_.Get(index);
}
inline void TriangleMesh::set_triangles(int index, ::google::protobuf::uint32 value) {
  triangles_.Set(index, value);
  // @@protoc_insertion_point(field_set:CreateDOM.TriangleMesh.triangles)
}
inline void TriangleMesh::add_triangles(::google::protobuf::uint32 value) {
  triangles_.Add(value);
  // @@protoc_insertion_point(field_add:CreateDOM.TriangleMesh.triangles)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TriangleMesh::triangles() const {
  // @@protoc_insertion_point(field_list:CreateDOM.TriangleMesh.triangles)
  return triangles_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TriangleMesh::mutable_triangles() {
  // @@protoc_insertion_point(field_mutable_list:CreateDOM.TriangleMesh.triangles)
  return &triangles_;
}

// repeated uint32 materialIndices = 3;
inline int TriangleMesh::materialindices_size() const {
  return materialindices_.size();
}
inline void TriangleMesh::clear_materialindices() {
  materialindices_.Clear();
}
inline ::google::protobuf::uint32 TriangleMesh::materialindices(int index) const {
  // @@protoc_insertion_point(field_get:CreateDOM.TriangleMesh.materialIndices)
  return materialindices_.Get(index);
}
inline void TriangleMesh::set_materialindices(int index, ::google::protobuf::uint32 value) {
  materialindices_.Set(index, value);
  // @@protoc_insertion_point(field_set:CreateDOM.TriangleMesh.materialIndices)
}
inline void TriangleMesh::add_materialindices(::google::protobuf::uint32 value) {
  materialindices_.Add(value);
  // @@protoc_insertion_point(field_add:CreateDOM.TriangleMesh.materialIndices)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TriangleMesh::materialindices() const {
  // @@protoc_insertion_point(field_list:CreateDOM.TriangleMesh.materialIndices)
  return materialindices_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TriangleMesh::mutable_materialindices() {
  // @@protoc_insertion_point(field_mutable_list:CreateDOM.TriangleMesh.materialIndices)
  return &materialindices_;
}

// -------------------------------------------------------------------

// HeightField

// uint32 rowCount = 1;
inline void HeightField::clear_rowcount() {
  rowcount_ = 0u;
}
inline ::google::protobuf::uint32 HeightField::rowcount() const {
  // @@protoc_insertion_point(field_get:CreateDOM.HeightField.rowCount)
  return rowcount_;
}
inline void HeightField::set_rowcount(::google::protobuf::uint32 value) {
  
  rowcount_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.HeightField.rowCount)
}

// uint32 columnCount = 2;
inline void HeightField::clear_columncount() {
  columncount_ = 0u;
}
inline ::google::protobuf::uint32 HeightField::columncount() const {
  // @@protoc_insertion_point(field_get:CreateDOM.HeightField.columnCount)
  return columncount_;
}
inline void HeightField::set_columncount(::google::protobuf::uint32 value) {
  
  columncount_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.HeightField.columnCount)
}

// repeated uint32 samples = 3;
inline int HeightField::samples_size() const {
  return samples_.size();
}
inline void HeightField::clear_samples() {
  samples_.Clear();
}
inline ::google::protobuf::uint32 HeightField::samples(int index) const {
  // @@protoc_insertion_point(field_get:CreateDOM.HeightField.samples)
  return samples_.Get(index);
}
inline void HeightField::set_samples(int index, ::google::protobuf::uint32 value) {
  samples_.Set(index, value);
  // @@protoc_insertion_point(field_set:CreateDOM.HeightField.samples)
}
inline void HeightField::add_samples(::google::protobuf::uint32 value) {
  samples_.Add(value);
  // @@protoc_insertion_point(field_add:CreateDOM.HeightField.samples)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
HeightField::samples() const {
  // @@protoc_insertion_point(field_list:CreateDOM.HeightField.samples)
  return samples_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
HeightField::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:CreateDOM.HeightField.samples)
  return &samples_;
}

// repeated uint32 metaData = 4;
inline int HeightField::metadata_size() const {
  return metadata_.size();
}
inline void HeightField::clear_metadata() {
  metadata_.Clear();
}
inline ::google::protobuf::uint32 HeightField::metadata(int index) const {
  // @@protoc_insertion_point(field_get:CreateDOM.HeightField.metaData)
  return metadata_.Get(index);
}
inline void HeightField::set_metadata(int index, ::google::protobuf::uint32 value) {
  metadata_.Set(index, value);
  // @@protoc_insertion_point(field_set:CreateDOM.HeightField.metaData)
}
inline void HeightField::add_metadata(::google::protobuf::uint32 value) {
  metadata_.Add(value);
  // @@protoc_insertion_point(field_add:CreateDOM.HeightField.metaData)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
HeightField::metadata() const {
  // @@protoc_insertion_point(field_list:CreateDOM.HeightField.metaData)
  return metadata_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
HeightField::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:CreateDOM.HeightField.metaData)
  return &metadata_;
}

// -------------------------------------------------------------------

// Geometry

// .CreateDOM.GeometryType type = 1;
inline void Geometry::clear_type() {
  type_ = 0;
}
inline ::CreateDOM::GeometryType Geometry::type() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Geometry.type)
  return static_cast< ::CreateDOM::GeometryType >(type_);
}
inline void Geometry::set_type(::CreateDOM::GeometryType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.Geometry.type)
}

// .CreateDOM.BoxGeometry boxGeometry = 2;
inline bool Geometry::has_boxgeometry() const {
  return subtype_case() == kBoxGeometry;
}
inline void Geometry::set_has_boxgeometry() {
  _oneof_case_[0] = kBoxGeometry;
}
inline void Geometry::clear_boxgeometry() {
  if (has_boxgeometry()) {
    delete subtype_.boxgeometry_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::BoxGeometry& Geometry::boxgeometry() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Geometry.boxGeometry)
  return has_boxgeometry()
      ? *subtype_.boxgeometry_
      : ::CreateDOM::BoxGeometry::default_instance();
}
inline ::CreateDOM::BoxGeometry* Geometry::mutable_boxgeometry() {
  if (!has_boxgeometry()) {
    clear_subtype();
    set_has_boxgeometry();
    subtype_.boxgeometry_ = new ::CreateDOM::BoxGeometry;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Geometry.boxGeometry)
  return subtype_.boxgeometry_;
}
inline ::CreateDOM::BoxGeometry* Geometry::release_boxgeometry() {
  // @@protoc_insertion_point(field_release:CreateDOM.Geometry.boxGeometry)
  if (has_boxgeometry()) {
    clear_has_subtype();
    ::CreateDOM::BoxGeometry* temp = subtype_.boxgeometry_;
    subtype_.boxgeometry_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Geometry::set_allocated_boxgeometry(::CreateDOM::BoxGeometry* boxgeometry) {
  clear_subtype();
  if (boxgeometry) {
    set_has_boxgeometry();
    subtype_.boxgeometry_ = boxgeometry;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Geometry.boxGeometry)
}

// .CreateDOM.SphereGeometry sphereGeometry = 3;
inline bool Geometry::has_spheregeometry() const {
  return subtype_case() == kSphereGeometry;
}
inline void Geometry::set_has_spheregeometry() {
  _oneof_case_[0] = kSphereGeometry;
}
inline void Geometry::clear_spheregeometry() {
  if (has_spheregeometry()) {
    delete subtype_.spheregeometry_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::SphereGeometry& Geometry::spheregeometry() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Geometry.sphereGeometry)
  return has_spheregeometry()
      ? *subtype_.spheregeometry_
      : ::CreateDOM::SphereGeometry::default_instance();
}
inline ::CreateDOM::SphereGeometry* Geometry::mutable_spheregeometry() {
  if (!has_spheregeometry()) {
    clear_subtype();
    set_has_spheregeometry();
    subtype_.spheregeometry_ = new ::CreateDOM::SphereGeometry;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Geometry.sphereGeometry)
  return subtype_.spheregeometry_;
}
inline ::CreateDOM::SphereGeometry* Geometry::release_spheregeometry() {
  // @@protoc_insertion_point(field_release:CreateDOM.Geometry.sphereGeometry)
  if (has_spheregeometry()) {
    clear_has_subtype();
    ::CreateDOM::SphereGeometry* temp = subtype_.spheregeometry_;
    subtype_.spheregeometry_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Geometry::set_allocated_spheregeometry(::CreateDOM::SphereGeometry* spheregeometry) {
  clear_subtype();
  if (spheregeometry) {
    set_has_spheregeometry();
    subtype_.spheregeometry_ = spheregeometry;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Geometry.sphereGeometry)
}

// .CreateDOM.CapsuleGeometry capsuleGeometry = 4;
inline bool Geometry::has_capsulegeometry() const {
  return subtype_case() == kCapsuleGeometry;
}
inline void Geometry::set_has_capsulegeometry() {
  _oneof_case_[0] = kCapsuleGeometry;
}
inline void Geometry::clear_capsulegeometry() {
  if (has_capsulegeometry()) {
    delete subtype_.capsulegeometry_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::CapsuleGeometry& Geometry::capsulegeometry() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Geometry.capsuleGeometry)
  return has_capsulegeometry()
      ? *subtype_.capsulegeometry_
      : ::CreateDOM::CapsuleGeometry::default_instance();
}
inline ::CreateDOM::CapsuleGeometry* Geometry::mutable_capsulegeometry() {
  if (!has_capsulegeometry()) {
    clear_subtype();
    set_has_capsulegeometry();
    subtype_.capsulegeometry_ = new ::CreateDOM::CapsuleGeometry;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Geometry.capsuleGeometry)
  return subtype_.capsulegeometry_;
}
inline ::CreateDOM::CapsuleGeometry* Geometry::release_capsulegeometry() {
  // @@protoc_insertion_point(field_release:CreateDOM.Geometry.capsuleGeometry)
  if (has_capsulegeometry()) {
    clear_has_subtype();
    ::CreateDOM::CapsuleGeometry* temp = subtype_.capsulegeometry_;
    subtype_.capsulegeometry_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Geometry::set_allocated_capsulegeometry(::CreateDOM::CapsuleGeometry* capsulegeometry) {
  clear_subtype();
  if (capsulegeometry) {
    set_has_capsulegeometry();
    subtype_.capsulegeometry_ = capsulegeometry;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Geometry.capsuleGeometry)
}

// .CreateDOM.CylinderGeometry cylinderGeometry = 5;
inline bool Geometry::has_cylindergeometry() const {
  return subtype_case() == kCylinderGeometry;
}
inline void Geometry::set_has_cylindergeometry() {
  _oneof_case_[0] = kCylinderGeometry;
}
inline void Geometry::clear_cylindergeometry() {
  if (has_cylindergeometry()) {
    delete subtype_.cylindergeometry_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::CylinderGeometry& Geometry::cylindergeometry() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Geometry.cylinderGeometry)
  return has_cylindergeometry()
      ? *subtype_.cylindergeometry_
      : ::CreateDOM::CylinderGeometry::default_instance();
}
inline ::CreateDOM::CylinderGeometry* Geometry::mutable_cylindergeometry() {
  if (!has_cylindergeometry()) {
    clear_subtype();
    set_has_cylindergeometry();
    subtype_.cylindergeometry_ = new ::CreateDOM::CylinderGeometry;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Geometry.cylinderGeometry)
  return subtype_.cylindergeometry_;
}
inline ::CreateDOM::CylinderGeometry* Geometry::release_cylindergeometry() {
  // @@protoc_insertion_point(field_release:CreateDOM.Geometry.cylinderGeometry)
  if (has_cylindergeometry()) {
    clear_has_subtype();
    ::CreateDOM::CylinderGeometry* temp = subtype_.cylindergeometry_;
    subtype_.cylindergeometry_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Geometry::set_allocated_cylindergeometry(::CreateDOM::CylinderGeometry* cylindergeometry) {
  clear_subtype();
  if (cylindergeometry) {
    set_has_cylindergeometry();
    subtype_.cylindergeometry_ = cylindergeometry;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Geometry.cylinderGeometry)
}

// .CreateDOM.ConvexHullGeometry convexHullGeometry = 6;
inline bool Geometry::has_convexhullgeometry() const {
  return subtype_case() == kConvexHullGeometry;
}
inline void Geometry::set_has_convexhullgeometry() {
  _oneof_case_[0] = kConvexHullGeometry;
}
inline void Geometry::clear_convexhullgeometry() {
  if (has_convexhullgeometry()) {
    delete subtype_.convexhullgeometry_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::ConvexHullGeometry& Geometry::convexhullgeometry() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Geometry.convexHullGeometry)
  return has_convexhullgeometry()
      ? *subtype_.convexhullgeometry_
      : ::CreateDOM::ConvexHullGeometry::default_instance();
}
inline ::CreateDOM::ConvexHullGeometry* Geometry::mutable_convexhullgeometry() {
  if (!has_convexhullgeometry()) {
    clear_subtype();
    set_has_convexhullgeometry();
    subtype_.convexhullgeometry_ = new ::CreateDOM::ConvexHullGeometry;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Geometry.convexHullGeometry)
  return subtype_.convexhullgeometry_;
}
inline ::CreateDOM::ConvexHullGeometry* Geometry::release_convexhullgeometry() {
  // @@protoc_insertion_point(field_release:CreateDOM.Geometry.convexHullGeometry)
  if (has_convexhullgeometry()) {
    clear_has_subtype();
    ::CreateDOM::ConvexHullGeometry* temp = subtype_.convexhullgeometry_;
    subtype_.convexhullgeometry_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Geometry::set_allocated_convexhullgeometry(::CreateDOM::ConvexHullGeometry* convexhullgeometry) {
  clear_subtype();
  if (convexhullgeometry) {
    set_has_convexhullgeometry();
    subtype_.convexhullgeometry_ = convexhullgeometry;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Geometry.convexHullGeometry)
}

// .CreateDOM.TriangleMeshGeometry triangleMeshGeometry = 7;
inline bool Geometry::has_trianglemeshgeometry() const {
  return subtype_case() == kTriangleMeshGeometry;
}
inline void Geometry::set_has_trianglemeshgeometry() {
  _oneof_case_[0] = kTriangleMeshGeometry;
}
inline void Geometry::clear_trianglemeshgeometry() {
  if (has_trianglemeshgeometry()) {
    delete subtype_.trianglemeshgeometry_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::TriangleMeshGeometry& Geometry::trianglemeshgeometry() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Geometry.triangleMeshGeometry)
  return has_trianglemeshgeometry()
      ? *subtype_.trianglemeshgeometry_
      : ::CreateDOM::TriangleMeshGeometry::default_instance();
}
inline ::CreateDOM::TriangleMeshGeometry* Geometry::mutable_trianglemeshgeometry() {
  if (!has_trianglemeshgeometry()) {
    clear_subtype();
    set_has_trianglemeshgeometry();
    subtype_.trianglemeshgeometry_ = new ::CreateDOM::TriangleMeshGeometry;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Geometry.triangleMeshGeometry)
  return subtype_.trianglemeshgeometry_;
}
inline ::CreateDOM::TriangleMeshGeometry* Geometry::release_trianglemeshgeometry() {
  // @@protoc_insertion_point(field_release:CreateDOM.Geometry.triangleMeshGeometry)
  if (has_trianglemeshgeometry()) {
    clear_has_subtype();
    ::CreateDOM::TriangleMeshGeometry* temp = subtype_.trianglemeshgeometry_;
    subtype_.trianglemeshgeometry_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Geometry::set_allocated_trianglemeshgeometry(::CreateDOM::TriangleMeshGeometry* trianglemeshgeometry) {
  clear_subtype();
  if (trianglemeshgeometry) {
    set_has_trianglemeshgeometry();
    subtype_.trianglemeshgeometry_ = trianglemeshgeometry;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Geometry.triangleMeshGeometry)
}

// .CreateDOM.HeightFieldGeometry heightFieldGeometry = 8;
inline bool Geometry::has_heightfieldgeometry() const {
  return subtype_case() == kHeightFieldGeometry;
}
inline void Geometry::set_has_heightfieldgeometry() {
  _oneof_case_[0] = kHeightFieldGeometry;
}
inline void Geometry::clear_heightfieldgeometry() {
  if (has_heightfieldgeometry()) {
    delete subtype_.heightfieldgeometry_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::HeightFieldGeometry& Geometry::heightfieldgeometry() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Geometry.heightFieldGeometry)
  return has_heightfieldgeometry()
      ? *subtype_.heightfieldgeometry_
      : ::CreateDOM::HeightFieldGeometry::default_instance();
}
inline ::CreateDOM::HeightFieldGeometry* Geometry::mutable_heightfieldgeometry() {
  if (!has_heightfieldgeometry()) {
    clear_subtype();
    set_has_heightfieldgeometry();
    subtype_.heightfieldgeometry_ = new ::CreateDOM::HeightFieldGeometry;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Geometry.heightFieldGeometry)
  return subtype_.heightfieldgeometry_;
}
inline ::CreateDOM::HeightFieldGeometry* Geometry::release_heightfieldgeometry() {
  // @@protoc_insertion_point(field_release:CreateDOM.Geometry.heightFieldGeometry)
  if (has_heightfieldgeometry()) {
    clear_has_subtype();
    ::CreateDOM::HeightFieldGeometry* temp = subtype_.heightfieldgeometry_;
    subtype_.heightfieldgeometry_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Geometry::set_allocated_heightfieldgeometry(::CreateDOM::HeightFieldGeometry* heightfieldgeometry) {
  clear_subtype();
  if (heightfieldgeometry) {
    set_has_heightfieldgeometry();
    subtype_.heightfieldgeometry_ = heightfieldgeometry;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Geometry.heightFieldGeometry)
}

// .CreateDOM.PlaneGeometry planeGeometry = 9;
inline bool Geometry::has_planegeometry() const {
  return subtype_case() == kPlaneGeometry;
}
inline void Geometry::set_has_planegeometry() {
  _oneof_case_[0] = kPlaneGeometry;
}
inline void Geometry::clear_planegeometry() {
  if (has_planegeometry()) {
    delete subtype_.planegeometry_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::PlaneGeometry& Geometry::planegeometry() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Geometry.planeGeometry)
  return has_planegeometry()
      ? *subtype_.planegeometry_
      : ::CreateDOM::PlaneGeometry::default_instance();
}
inline ::CreateDOM::PlaneGeometry* Geometry::mutable_planegeometry() {
  if (!has_planegeometry()) {
    clear_subtype();
    set_has_planegeometry();
    subtype_.planegeometry_ = new ::CreateDOM::PlaneGeometry;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Geometry.planeGeometry)
  return subtype_.planegeometry_;
}
inline ::CreateDOM::PlaneGeometry* Geometry::release_planegeometry() {
  // @@protoc_insertion_point(field_release:CreateDOM.Geometry.planeGeometry)
  if (has_planegeometry()) {
    clear_has_subtype();
    ::CreateDOM::PlaneGeometry* temp = subtype_.planegeometry_;
    subtype_.planegeometry_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Geometry::set_allocated_planegeometry(::CreateDOM::PlaneGeometry* planegeometry) {
  clear_subtype();
  if (planegeometry) {
    set_has_planegeometry();
    subtype_.planegeometry_ = planegeometry;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Geometry.planeGeometry)
}

inline bool Geometry::has_subtype() const {
  return subtype_case() != SUBTYPE_NOT_SET;
}
inline void Geometry::clear_has_subtype() {
  _oneof_case_[0] = SUBTYPE_NOT_SET;
}
inline Geometry::SubtypeCase Geometry::subtype_case() const {
  return Geometry::SubtypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BoxGeometry

// .CreateDOM.Vec3 dimensions = 1;
inline bool BoxGeometry::has_dimensions() const {
  return this != internal_default_instance() && dimensions_ != NULL;
}
inline void BoxGeometry::clear_dimensions() {
  if (GetArenaNoVirtual() == NULL && dimensions_ != NULL) delete dimensions_;
  dimensions_ = NULL;
}
inline const ::CreateDOM::Vec3& BoxGeometry::dimensions() const {
  const ::CreateDOM::Vec3* p = dimensions_;
  // @@protoc_insertion_point(field_get:CreateDOM.BoxGeometry.dimensions)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Vec3*>(
      &::CreateDOM::_Vec3_default_instance_);
}
inline ::CreateDOM::Vec3* BoxGeometry::mutable_dimensions() {
  
  if (dimensions_ == NULL) {
    dimensions_ = new ::CreateDOM::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.BoxGeometry.dimensions)
  return dimensions_;
}
inline ::CreateDOM::Vec3* BoxGeometry::release_dimensions() {
  // @@protoc_insertion_point(field_release:CreateDOM.BoxGeometry.dimensions)
  
  ::CreateDOM::Vec3* temp = dimensions_;
  dimensions_ = NULL;
  return temp;
}
inline void BoxGeometry::set_allocated_dimensions(::CreateDOM::Vec3* dimensions) {
  delete dimensions_;
  dimensions_ = dimensions;
  if (dimensions) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.BoxGeometry.dimensions)
}

// -------------------------------------------------------------------

// SphereGeometry

// float radius = 1;
inline void SphereGeometry::clear_radius() {
  radius_ = 0;
}
inline float SphereGeometry::radius() const {
  // @@protoc_insertion_point(field_get:CreateDOM.SphereGeometry.radius)
  return radius_;
}
inline void SphereGeometry::set_radius(float value) {
  
  radius_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.SphereGeometry.radius)
}

// -------------------------------------------------------------------

// CapsuleGeometry

// float radius = 1;
inline void CapsuleGeometry::clear_radius() {
  radius_ = 0;
}
inline float CapsuleGeometry::radius() const {
  // @@protoc_insertion_point(field_get:CreateDOM.CapsuleGeometry.radius)
  return radius_;
}
inline void CapsuleGeometry::set_radius(float value) {
  
  radius_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.CapsuleGeometry.radius)
}

// float height = 2;
inline void CapsuleGeometry::clear_height() {
  height_ = 0;
}
inline float CapsuleGeometry::height() const {
  // @@protoc_insertion_point(field_get:CreateDOM.CapsuleGeometry.height)
  return height_;
}
inline void CapsuleGeometry::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.CapsuleGeometry.height)
}

// -------------------------------------------------------------------

// CylinderGeometry

// float radius = 1;
inline void CylinderGeometry::clear_radius() {
  radius_ = 0;
}
inline float CylinderGeometry::radius() const {
  // @@protoc_insertion_point(field_get:CreateDOM.CylinderGeometry.radius)
  return radius_;
}
inline void CylinderGeometry::set_radius(float value) {
  
  radius_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.CylinderGeometry.radius)
}

// float height = 2;
inline void CylinderGeometry::clear_height() {
  height_ = 0;
}
inline float CylinderGeometry::height() const {
  // @@protoc_insertion_point(field_get:CreateDOM.CylinderGeometry.height)
  return height_;
}
inline void CylinderGeometry::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.CylinderGeometry.height)
}

// -------------------------------------------------------------------

// ConvexHullGeometry

// .CreateDOM.MeshScale scale = 1;
inline bool ConvexHullGeometry::has_scale() const {
  return this != internal_default_instance() && scale_ != NULL;
}
inline void ConvexHullGeometry::clear_scale() {
  if (GetArenaNoVirtual() == NULL && scale_ != NULL) delete scale_;
  scale_ = NULL;
}
inline const ::CreateDOM::MeshScale& ConvexHullGeometry::scale() const {
  const ::CreateDOM::MeshScale* p = scale_;
  // @@protoc_insertion_point(field_get:CreateDOM.ConvexHullGeometry.scale)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::MeshScale*>(
      &::CreateDOM::_MeshScale_default_instance_);
}
inline ::CreateDOM::MeshScale* ConvexHullGeometry::mutable_scale() {
  
  if (scale_ == NULL) {
    scale_ = new ::CreateDOM::MeshScale;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.ConvexHullGeometry.scale)
  return scale_;
}
inline ::CreateDOM::MeshScale* ConvexHullGeometry::release_scale() {
  // @@protoc_insertion_point(field_release:CreateDOM.ConvexHullGeometry.scale)
  
  ::CreateDOM::MeshScale* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void ConvexHullGeometry::set_allocated_scale(::CreateDOM::MeshScale* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.ConvexHullGeometry.scale)
}

// string convexMesh = 2;
inline void ConvexHullGeometry::clear_convexmesh() {
  convexmesh_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConvexHullGeometry::convexmesh() const {
  // @@protoc_insertion_point(field_get:CreateDOM.ConvexHullGeometry.convexMesh)
  return convexmesh_.GetNoArena();
}
inline void ConvexHullGeometry::set_convexmesh(const ::std::string& value) {
  
  convexmesh_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateDOM.ConvexHullGeometry.convexMesh)
}
#if LANG_CXX11
inline void ConvexHullGeometry::set_convexmesh(::std::string&& value) {
  
  convexmesh_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateDOM.ConvexHullGeometry.convexMesh)
}
#endif
inline void ConvexHullGeometry::set_convexmesh(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  convexmesh_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateDOM.ConvexHullGeometry.convexMesh)
}
inline void ConvexHullGeometry::set_convexmesh(const char* value, size_t size) {
  
  convexmesh_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateDOM.ConvexHullGeometry.convexMesh)
}
inline ::std::string* ConvexHullGeometry::mutable_convexmesh() {
  
  // @@protoc_insertion_point(field_mutable:CreateDOM.ConvexHullGeometry.convexMesh)
  return convexmesh_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConvexHullGeometry::release_convexmesh() {
  // @@protoc_insertion_point(field_release:CreateDOM.ConvexHullGeometry.convexMesh)
  
  return convexmesh_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConvexHullGeometry::set_allocated_convexmesh(::std::string* convexmesh) {
  if (convexmesh != NULL) {
    
  } else {
    
  }
  convexmesh_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), convexmesh);
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.ConvexHullGeometry.convexMesh)
}

// -------------------------------------------------------------------

// TriangleMeshGeometry

// .CreateDOM.MeshScale scale = 1;
inline bool TriangleMeshGeometry::has_scale() const {
  return this != internal_default_instance() && scale_ != NULL;
}
inline void TriangleMeshGeometry::clear_scale() {
  if (GetArenaNoVirtual() == NULL && scale_ != NULL) delete scale_;
  scale_ = NULL;
}
inline const ::CreateDOM::MeshScale& TriangleMeshGeometry::scale() const {
  const ::CreateDOM::MeshScale* p = scale_;
  // @@protoc_insertion_point(field_get:CreateDOM.TriangleMeshGeometry.scale)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::MeshScale*>(
      &::CreateDOM::_MeshScale_default_instance_);
}
inline ::CreateDOM::MeshScale* TriangleMeshGeometry::mutable_scale() {
  
  if (scale_ == NULL) {
    scale_ = new ::CreateDOM::MeshScale;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.TriangleMeshGeometry.scale)
  return scale_;
}
inline ::CreateDOM::MeshScale* TriangleMeshGeometry::release_scale() {
  // @@protoc_insertion_point(field_release:CreateDOM.TriangleMeshGeometry.scale)
  
  ::CreateDOM::MeshScale* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void TriangleMeshGeometry::set_allocated_scale(::CreateDOM::MeshScale* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.TriangleMeshGeometry.scale)
}

// string triangleMesh = 2;
inline void TriangleMeshGeometry::clear_trianglemesh() {
  trianglemesh_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TriangleMeshGeometry::trianglemesh() const {
  // @@protoc_insertion_point(field_get:CreateDOM.TriangleMeshGeometry.triangleMesh)
  return trianglemesh_.GetNoArena();
}
inline void TriangleMeshGeometry::set_trianglemesh(const ::std::string& value) {
  
  trianglemesh_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateDOM.TriangleMeshGeometry.triangleMesh)
}
#if LANG_CXX11
inline void TriangleMeshGeometry::set_trianglemesh(::std::string&& value) {
  
  trianglemesh_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateDOM.TriangleMeshGeometry.triangleMesh)
}
#endif
inline void TriangleMeshGeometry::set_trianglemesh(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  trianglemesh_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateDOM.TriangleMeshGeometry.triangleMesh)
}
inline void TriangleMeshGeometry::set_trianglemesh(const char* value, size_t size) {
  
  trianglemesh_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateDOM.TriangleMeshGeometry.triangleMesh)
}
inline ::std::string* TriangleMeshGeometry::mutable_trianglemesh() {
  
  // @@protoc_insertion_point(field_mutable:CreateDOM.TriangleMeshGeometry.triangleMesh)
  return trianglemesh_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TriangleMeshGeometry::release_trianglemesh() {
  // @@protoc_insertion_point(field_release:CreateDOM.TriangleMeshGeometry.triangleMesh)
  
  return trianglemesh_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TriangleMeshGeometry::set_allocated_trianglemesh(::std::string* trianglemesh) {
  if (trianglemesh != NULL) {
    
  } else {
    
  }
  trianglemesh_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trianglemesh);
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.TriangleMeshGeometry.triangleMesh)
}

// bool doubleSided = 3;
inline void TriangleMeshGeometry::clear_doublesided() {
  doublesided_ = false;
}
inline bool TriangleMeshGeometry::doublesided() const {
  // @@protoc_insertion_point(field_get:CreateDOM.TriangleMeshGeometry.doubleSided)
  return doublesided_;
}
inline void TriangleMeshGeometry::set_doublesided(bool value) {
  
  doublesided_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.TriangleMeshGeometry.doubleSided)
}

// -------------------------------------------------------------------

// HeightFieldGeometry

// string heightField = 1;
inline void HeightFieldGeometry::clear_heightfield() {
  heightfield_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HeightFieldGeometry::heightfield() const {
  // @@protoc_insertion_point(field_get:CreateDOM.HeightFieldGeometry.heightField)
  return heightfield_.GetNoArena();
}
inline void HeightFieldGeometry::set_heightfield(const ::std::string& value) {
  
  heightfield_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateDOM.HeightFieldGeometry.heightField)
}
#if LANG_CXX11
inline void HeightFieldGeometry::set_heightfield(::std::string&& value) {
  
  heightfield_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateDOM.HeightFieldGeometry.heightField)
}
#endif
inline void HeightFieldGeometry::set_heightfield(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  heightfield_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateDOM.HeightFieldGeometry.heightField)
}
inline void HeightFieldGeometry::set_heightfield(const char* value, size_t size) {
  
  heightfield_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateDOM.HeightFieldGeometry.heightField)
}
inline ::std::string* HeightFieldGeometry::mutable_heightfield() {
  
  // @@protoc_insertion_point(field_mutable:CreateDOM.HeightFieldGeometry.heightField)
  return heightfield_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeightFieldGeometry::release_heightfield() {
  // @@protoc_insertion_point(field_release:CreateDOM.HeightFieldGeometry.heightField)
  
  return heightfield_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeightFieldGeometry::set_allocated_heightfield(::std::string* heightfield) {
  if (heightfield != NULL) {
    
  } else {
    
  }
  heightfield_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), heightfield);
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.HeightFieldGeometry.heightField)
}

// float heightScale = 2;
inline void HeightFieldGeometry::clear_heightscale() {
  heightscale_ = 0;
}
inline float HeightFieldGeometry::heightscale() const {
  // @@protoc_insertion_point(field_get:CreateDOM.HeightFieldGeometry.heightScale)
  return heightscale_;
}
inline void HeightFieldGeometry::set_heightscale(float value) {
  
  heightscale_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.HeightFieldGeometry.heightScale)
}

// float rowScale = 3;
inline void HeightFieldGeometry::clear_rowscale() {
  rowscale_ = 0;
}
inline float HeightFieldGeometry::rowscale() const {
  // @@protoc_insertion_point(field_get:CreateDOM.HeightFieldGeometry.rowScale)
  return rowscale_;
}
inline void HeightFieldGeometry::set_rowscale(float value) {
  
  rowscale_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.HeightFieldGeometry.rowScale)
}

// float columnScale = 4;
inline void HeightFieldGeometry::clear_columnscale() {
  columnscale_ = 0;
}
inline float HeightFieldGeometry::columnscale() const {
  // @@protoc_insertion_point(field_get:CreateDOM.HeightFieldGeometry.columnScale)
  return columnscale_;
}
inline void HeightFieldGeometry::set_columnscale(float value) {
  
  columnscale_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.HeightFieldGeometry.columnScale)
}

// bool doubleSided = 5;
inline void HeightFieldGeometry::clear_doublesided() {
  doublesided_ = false;
}
inline bool HeightFieldGeometry::doublesided() const {
  // @@protoc_insertion_point(field_get:CreateDOM.HeightFieldGeometry.doubleSided)
  return doublesided_;
}
inline void HeightFieldGeometry::set_doublesided(bool value) {
  
  doublesided_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.HeightFieldGeometry.doubleSided)
}

// -------------------------------------------------------------------

// PlaneGeometry

// -------------------------------------------------------------------

// GeometryInstance

// .CreateDOM.Geometry geometry = 1;
inline bool GeometryInstance::has_geometry() const {
  return this != internal_default_instance() && geometry_ != NULL;
}
inline void GeometryInstance::clear_geometry() {
  if (GetArenaNoVirtual() == NULL && geometry_ != NULL) delete geometry_;
  geometry_ = NULL;
}
inline const ::CreateDOM::Geometry& GeometryInstance::geometry() const {
  const ::CreateDOM::Geometry* p = geometry_;
  // @@protoc_insertion_point(field_get:CreateDOM.GeometryInstance.geometry)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Geometry*>(
      &::CreateDOM::_Geometry_default_instance_);
}
inline ::CreateDOM::Geometry* GeometryInstance::mutable_geometry() {
  
  if (geometry_ == NULL) {
    geometry_ = new ::CreateDOM::Geometry;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.GeometryInstance.geometry)
  return geometry_;
}
inline ::CreateDOM::Geometry* GeometryInstance::release_geometry() {
  // @@protoc_insertion_point(field_release:CreateDOM.GeometryInstance.geometry)
  
  ::CreateDOM::Geometry* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline void GeometryInstance::set_allocated_geometry(::CreateDOM::Geometry* geometry) {
  delete geometry_;
  geometry_ = geometry;
  if (geometry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.GeometryInstance.geometry)
}

// repeated string materials = 2;
inline int GeometryInstance::materials_size() const {
  return materials_.size();
}
inline void GeometryInstance::clear_materials() {
  materials_.Clear();
}
inline const ::std::string& GeometryInstance::materials(int index) const {
  // @@protoc_insertion_point(field_get:CreateDOM.GeometryInstance.materials)
  return materials_.Get(index);
}
inline ::std::string* GeometryInstance::mutable_materials(int index) {
  // @@protoc_insertion_point(field_mutable:CreateDOM.GeometryInstance.materials)
  return materials_.Mutable(index);
}
inline void GeometryInstance::set_materials(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:CreateDOM.GeometryInstance.materials)
  materials_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GeometryInstance::set_materials(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:CreateDOM.GeometryInstance.materials)
  materials_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GeometryInstance::set_materials(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  materials_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CreateDOM.GeometryInstance.materials)
}
inline void GeometryInstance::set_materials(int index, const char* value, size_t size) {
  materials_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CreateDOM.GeometryInstance.materials)
}
inline ::std::string* GeometryInstance::add_materials() {
  // @@protoc_insertion_point(field_add_mutable:CreateDOM.GeometryInstance.materials)
  return materials_.Add();
}
inline void GeometryInstance::add_materials(const ::std::string& value) {
  materials_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CreateDOM.GeometryInstance.materials)
}
#if LANG_CXX11
inline void GeometryInstance::add_materials(::std::string&& value) {
  materials_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CreateDOM.GeometryInstance.materials)
}
#endif
inline void GeometryInstance::add_materials(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  materials_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CreateDOM.GeometryInstance.materials)
}
inline void GeometryInstance::add_materials(const char* value, size_t size) {
  materials_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CreateDOM.GeometryInstance.materials)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GeometryInstance::materials() const {
  // @@protoc_insertion_point(field_list:CreateDOM.GeometryInstance.materials)
  return materials_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GeometryInstance::mutable_materials() {
  // @@protoc_insertion_point(field_mutable_list:CreateDOM.GeometryInstance.materials)
  return &materials_;
}

// .CreateDOM.Pose localPose = 3;
inline bool GeometryInstance::has_localpose() const {
  return this != internal_default_instance() && localpose_ != NULL;
}
inline void GeometryInstance::clear_localpose() {
  if (GetArenaNoVirtual() == NULL && localpose_ != NULL) delete localpose_;
  localpose_ = NULL;
}
inline const ::CreateDOM::Pose& GeometryInstance::localpose() const {
  const ::CreateDOM::Pose* p = localpose_;
  // @@protoc_insertion_point(field_get:CreateDOM.GeometryInstance.localPose)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Pose*>(
      &::CreateDOM::_Pose_default_instance_);
}
inline ::CreateDOM::Pose* GeometryInstance::mutable_localpose() {
  
  if (localpose_ == NULL) {
    localpose_ = new ::CreateDOM::Pose;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.GeometryInstance.localPose)
  return localpose_;
}
inline ::CreateDOM::Pose* GeometryInstance::release_localpose() {
  // @@protoc_insertion_point(field_release:CreateDOM.GeometryInstance.localPose)
  
  ::CreateDOM::Pose* temp = localpose_;
  localpose_ = NULL;
  return temp;
}
inline void GeometryInstance::set_allocated_localpose(::CreateDOM::Pose* localpose) {
  delete localpose_;
  localpose_ = localpose;
  if (localpose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.GeometryInstance.localPose)
}

// string collisionFilterSettings = 4;
inline void GeometryInstance::clear_collisionfiltersettings() {
  collisionfiltersettings_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GeometryInstance::collisionfiltersettings() const {
  // @@protoc_insertion_point(field_get:CreateDOM.GeometryInstance.collisionFilterSettings)
  return collisionfiltersettings_.GetNoArena();
}
inline void GeometryInstance::set_collisionfiltersettings(const ::std::string& value) {
  
  collisionfiltersettings_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateDOM.GeometryInstance.collisionFilterSettings)
}
#if LANG_CXX11
inline void GeometryInstance::set_collisionfiltersettings(::std::string&& value) {
  
  collisionfiltersettings_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateDOM.GeometryInstance.collisionFilterSettings)
}
#endif
inline void GeometryInstance::set_collisionfiltersettings(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  collisionfiltersettings_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateDOM.GeometryInstance.collisionFilterSettings)
}
inline void GeometryInstance::set_collisionfiltersettings(const char* value, size_t size) {
  
  collisionfiltersettings_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateDOM.GeometryInstance.collisionFilterSettings)
}
inline ::std::string* GeometryInstance::mutable_collisionfiltersettings() {
  
  // @@protoc_insertion_point(field_mutable:CreateDOM.GeometryInstance.collisionFilterSettings)
  return collisionfiltersettings_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GeometryInstance::release_collisionfiltersettings() {
  // @@protoc_insertion_point(field_release:CreateDOM.GeometryInstance.collisionFilterSettings)
  
  return collisionfiltersettings_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GeometryInstance::set_allocated_collisionfiltersettings(::std::string* collisionfiltersettings) {
  if (collisionfiltersettings != NULL) {
    
  } else {
    
  }
  collisionfiltersettings_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collisionfiltersettings);
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.GeometryInstance.collisionFilterSettings)
}

// -------------------------------------------------------------------

// RigidBody

// repeated .CreateDOM.GeometryInstance geometryInstances = 1;
inline int RigidBody::geometryinstances_size() const {
  return geometryinstances_.size();
}
inline void RigidBody::clear_geometryinstances() {
  geometryinstances_.Clear();
}
inline const ::CreateDOM::GeometryInstance& RigidBody::geometryinstances(int index) const {
  // @@protoc_insertion_point(field_get:CreateDOM.RigidBody.geometryInstances)
  return geometryinstances_.Get(index);
}
inline ::CreateDOM::GeometryInstance* RigidBody::mutable_geometryinstances(int index) {
  // @@protoc_insertion_point(field_mutable:CreateDOM.RigidBody.geometryInstances)
  return geometryinstances_.Mutable(index);
}
inline ::CreateDOM::GeometryInstance* RigidBody::add_geometryinstances() {
  // @@protoc_insertion_point(field_add:CreateDOM.RigidBody.geometryInstances)
  return geometryinstances_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CreateDOM::GeometryInstance >*
RigidBody::mutable_geometryinstances() {
  // @@protoc_insertion_point(field_mutable_list:CreateDOM.RigidBody.geometryInstances)
  return &geometryinstances_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CreateDOM::GeometryInstance >&
RigidBody::geometryinstances() const {
  // @@protoc_insertion_point(field_list:CreateDOM.RigidBody.geometryInstances)
  return geometryinstances_;
}

// .CreateDOM.Pose globalPose = 2;
inline bool RigidBody::has_globalpose() const {
  return this != internal_default_instance() && globalpose_ != NULL;
}
inline void RigidBody::clear_globalpose() {
  if (GetArenaNoVirtual() == NULL && globalpose_ != NULL) delete globalpose_;
  globalpose_ = NULL;
}
inline const ::CreateDOM::Pose& RigidBody::globalpose() const {
  const ::CreateDOM::Pose* p = globalpose_;
  // @@protoc_insertion_point(field_get:CreateDOM.RigidBody.globalPose)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Pose*>(
      &::CreateDOM::_Pose_default_instance_);
}
inline ::CreateDOM::Pose* RigidBody::mutable_globalpose() {
  
  if (globalpose_ == NULL) {
    globalpose_ = new ::CreateDOM::Pose;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.RigidBody.globalPose)
  return globalpose_;
}
inline ::CreateDOM::Pose* RigidBody::release_globalpose() {
  // @@protoc_insertion_point(field_release:CreateDOM.RigidBody.globalPose)
  
  ::CreateDOM::Pose* temp = globalpose_;
  globalpose_ = NULL;
  return temp;
}
inline void RigidBody::set_allocated_globalpose(::CreateDOM::Pose* globalpose) {
  delete globalpose_;
  globalpose_ = globalpose;
  if (globalpose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.RigidBody.globalPose)
}

// .CreateDOM.RigidStatic rigidStatic = 3;
inline bool RigidBody::has_rigidstatic() const {
  return subtype_case() == kRigidStatic;
}
inline void RigidBody::set_has_rigidstatic() {
  _oneof_case_[0] = kRigidStatic;
}
inline void RigidBody::clear_rigidstatic() {
  if (has_rigidstatic()) {
    delete subtype_.rigidstatic_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::RigidStatic& RigidBody::rigidstatic() const {
  // @@protoc_insertion_point(field_get:CreateDOM.RigidBody.rigidStatic)
  return has_rigidstatic()
      ? *subtype_.rigidstatic_
      : ::CreateDOM::RigidStatic::default_instance();
}
inline ::CreateDOM::RigidStatic* RigidBody::mutable_rigidstatic() {
  if (!has_rigidstatic()) {
    clear_subtype();
    set_has_rigidstatic();
    subtype_.rigidstatic_ = new ::CreateDOM::RigidStatic;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.RigidBody.rigidStatic)
  return subtype_.rigidstatic_;
}
inline ::CreateDOM::RigidStatic* RigidBody::release_rigidstatic() {
  // @@protoc_insertion_point(field_release:CreateDOM.RigidBody.rigidStatic)
  if (has_rigidstatic()) {
    clear_has_subtype();
    ::CreateDOM::RigidStatic* temp = subtype_.rigidstatic_;
    subtype_.rigidstatic_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RigidBody::set_allocated_rigidstatic(::CreateDOM::RigidStatic* rigidstatic) {
  clear_subtype();
  if (rigidstatic) {
    set_has_rigidstatic();
    subtype_.rigidstatic_ = rigidstatic;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.RigidBody.rigidStatic)
}

// .CreateDOM.RigidDynamic rigidDynamic = 4;
inline bool RigidBody::has_rigiddynamic() const {
  return subtype_case() == kRigidDynamic;
}
inline void RigidBody::set_has_rigiddynamic() {
  _oneof_case_[0] = kRigidDynamic;
}
inline void RigidBody::clear_rigiddynamic() {
  if (has_rigiddynamic()) {
    delete subtype_.rigiddynamic_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::RigidDynamic& RigidBody::rigiddynamic() const {
  // @@protoc_insertion_point(field_get:CreateDOM.RigidBody.rigidDynamic)
  return has_rigiddynamic()
      ? *subtype_.rigiddynamic_
      : ::CreateDOM::RigidDynamic::default_instance();
}
inline ::CreateDOM::RigidDynamic* RigidBody::mutable_rigiddynamic() {
  if (!has_rigiddynamic()) {
    clear_subtype();
    set_has_rigiddynamic();
    subtype_.rigiddynamic_ = new ::CreateDOM::RigidDynamic;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.RigidBody.rigidDynamic)
  return subtype_.rigiddynamic_;
}
inline ::CreateDOM::RigidDynamic* RigidBody::release_rigiddynamic() {
  // @@protoc_insertion_point(field_release:CreateDOM.RigidBody.rigidDynamic)
  if (has_rigiddynamic()) {
    clear_has_subtype();
    ::CreateDOM::RigidDynamic* temp = subtype_.rigiddynamic_;
    subtype_.rigiddynamic_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RigidBody::set_allocated_rigiddynamic(::CreateDOM::RigidDynamic* rigiddynamic) {
  clear_subtype();
  if (rigiddynamic) {
    set_has_rigiddynamic();
    subtype_.rigiddynamic_ = rigiddynamic;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.RigidBody.rigidDynamic)
}

inline bool RigidBody::has_subtype() const {
  return subtype_case() != SUBTYPE_NOT_SET;
}
inline void RigidBody::clear_has_subtype() {
  _oneof_case_[0] = SUBTYPE_NOT_SET;
}
inline RigidBody::SubtypeCase RigidBody::subtype_case() const {
  return RigidBody::SubtypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RigidStatic

// -------------------------------------------------------------------

// RigidDynamic

// bool disableGravity = 1;
inline void RigidDynamic::clear_disablegravity() {
  disablegravity_ = false;
}
inline bool RigidDynamic::disablegravity() const {
  // @@protoc_insertion_point(field_get:CreateDOM.RigidDynamic.disableGravity)
  return disablegravity_;
}
inline void RigidDynamic::set_disablegravity(bool value) {
  
  disablegravity_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.RigidDynamic.disableGravity)
}

// .CreateDOM.Pose centerOfMassLocalPose = 2;
inline bool RigidDynamic::has_centerofmasslocalpose() const {
  return this != internal_default_instance() && centerofmasslocalpose_ != NULL;
}
inline void RigidDynamic::clear_centerofmasslocalpose() {
  if (GetArenaNoVirtual() == NULL && centerofmasslocalpose_ != NULL) delete centerofmasslocalpose_;
  centerofmasslocalpose_ = NULL;
}
inline const ::CreateDOM::Pose& RigidDynamic::centerofmasslocalpose() const {
  const ::CreateDOM::Pose* p = centerofmasslocalpose_;
  // @@protoc_insertion_point(field_get:CreateDOM.RigidDynamic.centerOfMassLocalPose)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Pose*>(
      &::CreateDOM::_Pose_default_instance_);
}
inline ::CreateDOM::Pose* RigidDynamic::mutable_centerofmasslocalpose() {
  
  if (centerofmasslocalpose_ == NULL) {
    centerofmasslocalpose_ = new ::CreateDOM::Pose;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.RigidDynamic.centerOfMassLocalPose)
  return centerofmasslocalpose_;
}
inline ::CreateDOM::Pose* RigidDynamic::release_centerofmasslocalpose() {
  // @@protoc_insertion_point(field_release:CreateDOM.RigidDynamic.centerOfMassLocalPose)
  
  ::CreateDOM::Pose* temp = centerofmasslocalpose_;
  centerofmasslocalpose_ = NULL;
  return temp;
}
inline void RigidDynamic::set_allocated_centerofmasslocalpose(::CreateDOM::Pose* centerofmasslocalpose) {
  delete centerofmasslocalpose_;
  centerofmasslocalpose_ = centerofmasslocalpose;
  if (centerofmasslocalpose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.RigidDynamic.centerOfMassLocalPose)
}

// float mass = 3;
inline void RigidDynamic::clear_mass() {
  mass_ = 0;
}
inline float RigidDynamic::mass() const {
  // @@protoc_insertion_point(field_get:CreateDOM.RigidDynamic.mass)
  return mass_;
}
inline void RigidDynamic::set_mass(float value) {
  
  mass_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.RigidDynamic.mass)
}

// .CreateDOM.Vec3 massSpaceInertiaTensor = 4;
inline bool RigidDynamic::has_massspaceinertiatensor() const {
  return this != internal_default_instance() && massspaceinertiatensor_ != NULL;
}
inline void RigidDynamic::clear_massspaceinertiatensor() {
  if (GetArenaNoVirtual() == NULL && massspaceinertiatensor_ != NULL) delete massspaceinertiatensor_;
  massspaceinertiatensor_ = NULL;
}
inline const ::CreateDOM::Vec3& RigidDynamic::massspaceinertiatensor() const {
  const ::CreateDOM::Vec3* p = massspaceinertiatensor_;
  // @@protoc_insertion_point(field_get:CreateDOM.RigidDynamic.massSpaceInertiaTensor)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Vec3*>(
      &::CreateDOM::_Vec3_default_instance_);
}
inline ::CreateDOM::Vec3* RigidDynamic::mutable_massspaceinertiatensor() {
  
  if (massspaceinertiatensor_ == NULL) {
    massspaceinertiatensor_ = new ::CreateDOM::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.RigidDynamic.massSpaceInertiaTensor)
  return massspaceinertiatensor_;
}
inline ::CreateDOM::Vec3* RigidDynamic::release_massspaceinertiatensor() {
  // @@protoc_insertion_point(field_release:CreateDOM.RigidDynamic.massSpaceInertiaTensor)
  
  ::CreateDOM::Vec3* temp = massspaceinertiatensor_;
  massspaceinertiatensor_ = NULL;
  return temp;
}
inline void RigidDynamic::set_allocated_massspaceinertiatensor(::CreateDOM::Vec3* massspaceinertiatensor) {
  delete massspaceinertiatensor_;
  massspaceinertiatensor_ = massspaceinertiatensor;
  if (massspaceinertiatensor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.RigidDynamic.massSpaceInertiaTensor)
}

// .CreateDOM.Vec3 linearVelocity = 5;
inline bool RigidDynamic::has_linearvelocity() const {
  return this != internal_default_instance() && linearvelocity_ != NULL;
}
inline void RigidDynamic::clear_linearvelocity() {
  if (GetArenaNoVirtual() == NULL && linearvelocity_ != NULL) delete linearvelocity_;
  linearvelocity_ = NULL;
}
inline const ::CreateDOM::Vec3& RigidDynamic::linearvelocity() const {
  const ::CreateDOM::Vec3* p = linearvelocity_;
  // @@protoc_insertion_point(field_get:CreateDOM.RigidDynamic.linearVelocity)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Vec3*>(
      &::CreateDOM::_Vec3_default_instance_);
}
inline ::CreateDOM::Vec3* RigidDynamic::mutable_linearvelocity() {
  
  if (linearvelocity_ == NULL) {
    linearvelocity_ = new ::CreateDOM::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.RigidDynamic.linearVelocity)
  return linearvelocity_;
}
inline ::CreateDOM::Vec3* RigidDynamic::release_linearvelocity() {
  // @@protoc_insertion_point(field_release:CreateDOM.RigidDynamic.linearVelocity)
  
  ::CreateDOM::Vec3* temp = linearvelocity_;
  linearvelocity_ = NULL;
  return temp;
}
inline void RigidDynamic::set_allocated_linearvelocity(::CreateDOM::Vec3* linearvelocity) {
  delete linearvelocity_;
  linearvelocity_ = linearvelocity;
  if (linearvelocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.RigidDynamic.linearVelocity)
}

// .CreateDOM.Vec3 angularVelocity = 6;
inline bool RigidDynamic::has_angularvelocity() const {
  return this != internal_default_instance() && angularvelocity_ != NULL;
}
inline void RigidDynamic::clear_angularvelocity() {
  if (GetArenaNoVirtual() == NULL && angularvelocity_ != NULL) delete angularvelocity_;
  angularvelocity_ = NULL;
}
inline const ::CreateDOM::Vec3& RigidDynamic::angularvelocity() const {
  const ::CreateDOM::Vec3* p = angularvelocity_;
  // @@protoc_insertion_point(field_get:CreateDOM.RigidDynamic.angularVelocity)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Vec3*>(
      &::CreateDOM::_Vec3_default_instance_);
}
inline ::CreateDOM::Vec3* RigidDynamic::mutable_angularvelocity() {
  
  if (angularvelocity_ == NULL) {
    angularvelocity_ = new ::CreateDOM::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.RigidDynamic.angularVelocity)
  return angularvelocity_;
}
inline ::CreateDOM::Vec3* RigidDynamic::release_angularvelocity() {
  // @@protoc_insertion_point(field_release:CreateDOM.RigidDynamic.angularVelocity)
  
  ::CreateDOM::Vec3* temp = angularvelocity_;
  angularvelocity_ = NULL;
  return temp;
}
inline void RigidDynamic::set_allocated_angularvelocity(::CreateDOM::Vec3* angularvelocity) {
  delete angularvelocity_;
  angularvelocity_ = angularvelocity;
  if (angularvelocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.RigidDynamic.angularVelocity)
}

// float linearDamping = 7;
inline void RigidDynamic::clear_lineardamping() {
  lineardamping_ = 0;
}
inline float RigidDynamic::lineardamping() const {
  // @@protoc_insertion_point(field_get:CreateDOM.RigidDynamic.linearDamping)
  return lineardamping_;
}
inline void RigidDynamic::set_lineardamping(float value) {
  
  lineardamping_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.RigidDynamic.linearDamping)
}

// float angularDamping = 8;
inline void RigidDynamic::clear_angulardamping() {
  angulardamping_ = 0;
}
inline float RigidDynamic::angulardamping() const {
  // @@protoc_insertion_point(field_get:CreateDOM.RigidDynamic.angularDamping)
  return angulardamping_;
}
inline void RigidDynamic::set_angulardamping(float value) {
  
  angulardamping_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.RigidDynamic.angularDamping)
}

// float maxAngularVelocity = 9;
inline void RigidDynamic::clear_maxangularvelocity() {
  maxangularvelocity_ = 0;
}
inline float RigidDynamic::maxangularvelocity() const {
  // @@protoc_insertion_point(field_get:CreateDOM.RigidDynamic.maxAngularVelocity)
  return maxangularvelocity_;
}
inline void RigidDynamic::set_maxangularvelocity(float value) {
  
  maxangularvelocity_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.RigidDynamic.maxAngularVelocity)
}

// bool kinematic = 10;
inline void RigidDynamic::clear_kinematic() {
  kinematic_ = false;
}
inline bool RigidDynamic::kinematic() const {
  // @@protoc_insertion_point(field_get:CreateDOM.RigidDynamic.kinematic)
  return kinematic_;
}
inline void RigidDynamic::set_kinematic(bool value) {
  
  kinematic_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.RigidDynamic.kinematic)
}

// -------------------------------------------------------------------

// Joint

// string body0 = 1;
inline void Joint::clear_body0() {
  body0_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Joint::body0() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Joint.body0)
  return body0_.GetNoArena();
}
inline void Joint::set_body0(const ::std::string& value) {
  
  body0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateDOM.Joint.body0)
}
#if LANG_CXX11
inline void Joint::set_body0(::std::string&& value) {
  
  body0_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateDOM.Joint.body0)
}
#endif
inline void Joint::set_body0(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  body0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateDOM.Joint.body0)
}
inline void Joint::set_body0(const char* value, size_t size) {
  
  body0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateDOM.Joint.body0)
}
inline ::std::string* Joint::mutable_body0() {
  
  // @@protoc_insertion_point(field_mutable:CreateDOM.Joint.body0)
  return body0_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Joint::release_body0() {
  // @@protoc_insertion_point(field_release:CreateDOM.Joint.body0)
  
  return body0_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Joint::set_allocated_body0(::std::string* body0) {
  if (body0 != NULL) {
    
  } else {
    
  }
  body0_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body0);
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Joint.body0)
}

// string body1 = 2;
inline void Joint::clear_body1() {
  body1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Joint::body1() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Joint.body1)
  return body1_.GetNoArena();
}
inline void Joint::set_body1(const ::std::string& value) {
  
  body1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateDOM.Joint.body1)
}
#if LANG_CXX11
inline void Joint::set_body1(::std::string&& value) {
  
  body1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateDOM.Joint.body1)
}
#endif
inline void Joint::set_body1(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  body1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateDOM.Joint.body1)
}
inline void Joint::set_body1(const char* value, size_t size) {
  
  body1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateDOM.Joint.body1)
}
inline ::std::string* Joint::mutable_body1() {
  
  // @@protoc_insertion_point(field_mutable:CreateDOM.Joint.body1)
  return body1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Joint::release_body1() {
  // @@protoc_insertion_point(field_release:CreateDOM.Joint.body1)
  
  return body1_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Joint::set_allocated_body1(::std::string* body1) {
  if (body1 != NULL) {
    
  } else {
    
  }
  body1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body1);
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Joint.body1)
}

// .CreateDOM.Pose localpose0 = 3;
inline bool Joint::has_localpose0() const {
  return this != internal_default_instance() && localpose0_ != NULL;
}
inline void Joint::clear_localpose0() {
  if (GetArenaNoVirtual() == NULL && localpose0_ != NULL) delete localpose0_;
  localpose0_ = NULL;
}
inline const ::CreateDOM::Pose& Joint::localpose0() const {
  const ::CreateDOM::Pose* p = localpose0_;
  // @@protoc_insertion_point(field_get:CreateDOM.Joint.localpose0)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Pose*>(
      &::CreateDOM::_Pose_default_instance_);
}
inline ::CreateDOM::Pose* Joint::mutable_localpose0() {
  
  if (localpose0_ == NULL) {
    localpose0_ = new ::CreateDOM::Pose;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Joint.localpose0)
  return localpose0_;
}
inline ::CreateDOM::Pose* Joint::release_localpose0() {
  // @@protoc_insertion_point(field_release:CreateDOM.Joint.localpose0)
  
  ::CreateDOM::Pose* temp = localpose0_;
  localpose0_ = NULL;
  return temp;
}
inline void Joint::set_allocated_localpose0(::CreateDOM::Pose* localpose0) {
  delete localpose0_;
  localpose0_ = localpose0;
  if (localpose0) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Joint.localpose0)
}

// .CreateDOM.Pose localpose1 = 4;
inline bool Joint::has_localpose1() const {
  return this != internal_default_instance() && localpose1_ != NULL;
}
inline void Joint::clear_localpose1() {
  if (GetArenaNoVirtual() == NULL && localpose1_ != NULL) delete localpose1_;
  localpose1_ = NULL;
}
inline const ::CreateDOM::Pose& Joint::localpose1() const {
  const ::CreateDOM::Pose* p = localpose1_;
  // @@protoc_insertion_point(field_get:CreateDOM.Joint.localpose1)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Pose*>(
      &::CreateDOM::_Pose_default_instance_);
}
inline ::CreateDOM::Pose* Joint::mutable_localpose1() {
  
  if (localpose1_ == NULL) {
    localpose1_ = new ::CreateDOM::Pose;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Joint.localpose1)
  return localpose1_;
}
inline ::CreateDOM::Pose* Joint::release_localpose1() {
  // @@protoc_insertion_point(field_release:CreateDOM.Joint.localpose1)
  
  ::CreateDOM::Pose* temp = localpose1_;
  localpose1_ = NULL;
  return temp;
}
inline void Joint::set_allocated_localpose1(::CreateDOM::Pose* localpose1) {
  delete localpose1_;
  localpose1_ = localpose1;
  if (localpose1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Joint.localpose1)
}

// bool collisionEnabled = 5;
inline void Joint::clear_collisionenabled() {
  collisionenabled_ = false;
}
inline bool Joint::collisionenabled() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Joint.collisionEnabled)
  return collisionenabled_;
}
inline void Joint::set_collisionenabled(bool value) {
  
  collisionenabled_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.Joint.collisionEnabled)
}

// .CreateDOM.FixedJoint fixedJoint = 6;
inline bool Joint::has_fixedjoint() const {
  return subtype_case() == kFixedJoint;
}
inline void Joint::set_has_fixedjoint() {
  _oneof_case_[0] = kFixedJoint;
}
inline void Joint::clear_fixedjoint() {
  if (has_fixedjoint()) {
    delete subtype_.fixedjoint_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::FixedJoint& Joint::fixedjoint() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Joint.fixedJoint)
  return has_fixedjoint()
      ? *subtype_.fixedjoint_
      : ::CreateDOM::FixedJoint::default_instance();
}
inline ::CreateDOM::FixedJoint* Joint::mutable_fixedjoint() {
  if (!has_fixedjoint()) {
    clear_subtype();
    set_has_fixedjoint();
    subtype_.fixedjoint_ = new ::CreateDOM::FixedJoint;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Joint.fixedJoint)
  return subtype_.fixedjoint_;
}
inline ::CreateDOM::FixedJoint* Joint::release_fixedjoint() {
  // @@protoc_insertion_point(field_release:CreateDOM.Joint.fixedJoint)
  if (has_fixedjoint()) {
    clear_has_subtype();
    ::CreateDOM::FixedJoint* temp = subtype_.fixedjoint_;
    subtype_.fixedjoint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Joint::set_allocated_fixedjoint(::CreateDOM::FixedJoint* fixedjoint) {
  clear_subtype();
  if (fixedjoint) {
    set_has_fixedjoint();
    subtype_.fixedjoint_ = fixedjoint;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Joint.fixedJoint)
}

// .CreateDOM.SphericalJoint sphericalJoint = 7;
inline bool Joint::has_sphericaljoint() const {
  return subtype_case() == kSphericalJoint;
}
inline void Joint::set_has_sphericaljoint() {
  _oneof_case_[0] = kSphericalJoint;
}
inline void Joint::clear_sphericaljoint() {
  if (has_sphericaljoint()) {
    delete subtype_.sphericaljoint_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::SphericalJoint& Joint::sphericaljoint() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Joint.sphericalJoint)
  return has_sphericaljoint()
      ? *subtype_.sphericaljoint_
      : ::CreateDOM::SphericalJoint::default_instance();
}
inline ::CreateDOM::SphericalJoint* Joint::mutable_sphericaljoint() {
  if (!has_sphericaljoint()) {
    clear_subtype();
    set_has_sphericaljoint();
    subtype_.sphericaljoint_ = new ::CreateDOM::SphericalJoint;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Joint.sphericalJoint)
  return subtype_.sphericaljoint_;
}
inline ::CreateDOM::SphericalJoint* Joint::release_sphericaljoint() {
  // @@protoc_insertion_point(field_release:CreateDOM.Joint.sphericalJoint)
  if (has_sphericaljoint()) {
    clear_has_subtype();
    ::CreateDOM::SphericalJoint* temp = subtype_.sphericaljoint_;
    subtype_.sphericaljoint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Joint::set_allocated_sphericaljoint(::CreateDOM::SphericalJoint* sphericaljoint) {
  clear_subtype();
  if (sphericaljoint) {
    set_has_sphericaljoint();
    subtype_.sphericaljoint_ = sphericaljoint;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Joint.sphericalJoint)
}

// .CreateDOM.HingeJoint hingeJoint = 8;
inline bool Joint::has_hingejoint() const {
  return subtype_case() == kHingeJoint;
}
inline void Joint::set_has_hingejoint() {
  _oneof_case_[0] = kHingeJoint;
}
inline void Joint::clear_hingejoint() {
  if (has_hingejoint()) {
    delete subtype_.hingejoint_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::HingeJoint& Joint::hingejoint() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Joint.hingeJoint)
  return has_hingejoint()
      ? *subtype_.hingejoint_
      : ::CreateDOM::HingeJoint::default_instance();
}
inline ::CreateDOM::HingeJoint* Joint::mutable_hingejoint() {
  if (!has_hingejoint()) {
    clear_subtype();
    set_has_hingejoint();
    subtype_.hingejoint_ = new ::CreateDOM::HingeJoint;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Joint.hingeJoint)
  return subtype_.hingejoint_;
}
inline ::CreateDOM::HingeJoint* Joint::release_hingejoint() {
  // @@protoc_insertion_point(field_release:CreateDOM.Joint.hingeJoint)
  if (has_hingejoint()) {
    clear_has_subtype();
    ::CreateDOM::HingeJoint* temp = subtype_.hingejoint_;
    subtype_.hingejoint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Joint::set_allocated_hingejoint(::CreateDOM::HingeJoint* hingejoint) {
  clear_subtype();
  if (hingejoint) {
    set_has_hingejoint();
    subtype_.hingejoint_ = hingejoint;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Joint.hingeJoint)
}

// .CreateDOM.PrismaticJoint prismaticJoint = 9;
inline bool Joint::has_prismaticjoint() const {
  return subtype_case() == kPrismaticJoint;
}
inline void Joint::set_has_prismaticjoint() {
  _oneof_case_[0] = kPrismaticJoint;
}
inline void Joint::clear_prismaticjoint() {
  if (has_prismaticjoint()) {
    delete subtype_.prismaticjoint_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::PrismaticJoint& Joint::prismaticjoint() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Joint.prismaticJoint)
  return has_prismaticjoint()
      ? *subtype_.prismaticjoint_
      : ::CreateDOM::PrismaticJoint::default_instance();
}
inline ::CreateDOM::PrismaticJoint* Joint::mutable_prismaticjoint() {
  if (!has_prismaticjoint()) {
    clear_subtype();
    set_has_prismaticjoint();
    subtype_.prismaticjoint_ = new ::CreateDOM::PrismaticJoint;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Joint.prismaticJoint)
  return subtype_.prismaticjoint_;
}
inline ::CreateDOM::PrismaticJoint* Joint::release_prismaticjoint() {
  // @@protoc_insertion_point(field_release:CreateDOM.Joint.prismaticJoint)
  if (has_prismaticjoint()) {
    clear_has_subtype();
    ::CreateDOM::PrismaticJoint* temp = subtype_.prismaticjoint_;
    subtype_.prismaticjoint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Joint::set_allocated_prismaticjoint(::CreateDOM::PrismaticJoint* prismaticjoint) {
  clear_subtype();
  if (prismaticjoint) {
    set_has_prismaticjoint();
    subtype_.prismaticjoint_ = prismaticjoint;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Joint.prismaticJoint)
}

// .CreateDOM.DistanceJoint distanceJoint = 10;
inline bool Joint::has_distancejoint() const {
  return subtype_case() == kDistanceJoint;
}
inline void Joint::set_has_distancejoint() {
  _oneof_case_[0] = kDistanceJoint;
}
inline void Joint::clear_distancejoint() {
  if (has_distancejoint()) {
    delete subtype_.distancejoint_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::DistanceJoint& Joint::distancejoint() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Joint.distanceJoint)
  return has_distancejoint()
      ? *subtype_.distancejoint_
      : ::CreateDOM::DistanceJoint::default_instance();
}
inline ::CreateDOM::DistanceJoint* Joint::mutable_distancejoint() {
  if (!has_distancejoint()) {
    clear_subtype();
    set_has_distancejoint();
    subtype_.distancejoint_ = new ::CreateDOM::DistanceJoint;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Joint.distanceJoint)
  return subtype_.distancejoint_;
}
inline ::CreateDOM::DistanceJoint* Joint::release_distancejoint() {
  // @@protoc_insertion_point(field_release:CreateDOM.Joint.distanceJoint)
  if (has_distancejoint()) {
    clear_has_subtype();
    ::CreateDOM::DistanceJoint* temp = subtype_.distancejoint_;
    subtype_.distancejoint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Joint::set_allocated_distancejoint(::CreateDOM::DistanceJoint* distancejoint) {
  clear_subtype();
  if (distancejoint) {
    set_has_distancejoint();
    subtype_.distancejoint_ = distancejoint;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Joint.distanceJoint)
}

// .CreateDOM.BallAndSocketJoint ballAndSocketJoint = 11;
inline bool Joint::has_ballandsocketjoint() const {
  return subtype_case() == kBallAndSocketJoint;
}
inline void Joint::set_has_ballandsocketjoint() {
  _oneof_case_[0] = kBallAndSocketJoint;
}
inline void Joint::clear_ballandsocketjoint() {
  if (has_ballandsocketjoint()) {
    delete subtype_.ballandsocketjoint_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::BallAndSocketJoint& Joint::ballandsocketjoint() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Joint.ballAndSocketJoint)
  return has_ballandsocketjoint()
      ? *subtype_.ballandsocketjoint_
      : ::CreateDOM::BallAndSocketJoint::default_instance();
}
inline ::CreateDOM::BallAndSocketJoint* Joint::mutable_ballandsocketjoint() {
  if (!has_ballandsocketjoint()) {
    clear_subtype();
    set_has_ballandsocketjoint();
    subtype_.ballandsocketjoint_ = new ::CreateDOM::BallAndSocketJoint;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Joint.ballAndSocketJoint)
  return subtype_.ballandsocketjoint_;
}
inline ::CreateDOM::BallAndSocketJoint* Joint::release_ballandsocketjoint() {
  // @@protoc_insertion_point(field_release:CreateDOM.Joint.ballAndSocketJoint)
  if (has_ballandsocketjoint()) {
    clear_has_subtype();
    ::CreateDOM::BallAndSocketJoint* temp = subtype_.ballandsocketjoint_;
    subtype_.ballandsocketjoint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Joint::set_allocated_ballandsocketjoint(::CreateDOM::BallAndSocketJoint* ballandsocketjoint) {
  clear_subtype();
  if (ballandsocketjoint) {
    set_has_ballandsocketjoint();
    subtype_.ballandsocketjoint_ = ballandsocketjoint;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Joint.ballAndSocketJoint)
}

// .CreateDOM.D6Joint d6Joint = 12;
inline bool Joint::has_d6joint() const {
  return subtype_case() == kD6Joint;
}
inline void Joint::set_has_d6joint() {
  _oneof_case_[0] = kD6Joint;
}
inline void Joint::clear_d6joint() {
  if (has_d6joint()) {
    delete subtype_.d6joint_;
    clear_has_subtype();
  }
}
inline  const ::CreateDOM::D6Joint& Joint::d6joint() const {
  // @@protoc_insertion_point(field_get:CreateDOM.Joint.d6Joint)
  return has_d6joint()
      ? *subtype_.d6joint_
      : ::CreateDOM::D6Joint::default_instance();
}
inline ::CreateDOM::D6Joint* Joint::mutable_d6joint() {
  if (!has_d6joint()) {
    clear_subtype();
    set_has_d6joint();
    subtype_.d6joint_ = new ::CreateDOM::D6Joint;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Joint.d6Joint)
  return subtype_.d6joint_;
}
inline ::CreateDOM::D6Joint* Joint::release_d6joint() {
  // @@protoc_insertion_point(field_release:CreateDOM.Joint.d6Joint)
  if (has_d6joint()) {
    clear_has_subtype();
    ::CreateDOM::D6Joint* temp = subtype_.d6joint_;
    subtype_.d6joint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Joint::set_allocated_d6joint(::CreateDOM::D6Joint* d6joint) {
  clear_subtype();
  if (d6joint) {
    set_has_d6joint();
    subtype_.d6joint_ = d6joint;
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Joint.d6Joint)
}

inline bool Joint::has_subtype() const {
  return subtype_case() != SUBTYPE_NOT_SET;
}
inline void Joint::clear_has_subtype() {
  _oneof_case_[0] = SUBTYPE_NOT_SET;
}
inline Joint::SubtypeCase Joint::subtype_case() const {
  return Joint::SubtypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FixedJoint

// -------------------------------------------------------------------

// SphericalJoint

// float limitY = 1;
inline void SphericalJoint::clear_limity() {
  limity_ = 0;
}
inline float SphericalJoint::limity() const {
  // @@protoc_insertion_point(field_get:CreateDOM.SphericalJoint.limitY)
  return limity_;
}
inline void SphericalJoint::set_limity(float value) {
  
  limity_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.SphericalJoint.limitY)
}

// float limitZ = 2;
inline void SphericalJoint::clear_limitz() {
  limitz_ = 0;
}
inline float SphericalJoint::limitz() const {
  // @@protoc_insertion_point(field_get:CreateDOM.SphericalJoint.limitZ)
  return limitz_;
}
inline void SphericalJoint::set_limitz(float value) {
  
  limitz_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.SphericalJoint.limitZ)
}

// -------------------------------------------------------------------

// HingeJoint

// float limtLow = 1;
inline void HingeJoint::clear_limtlow() {
  limtlow_ = 0;
}
inline float HingeJoint::limtlow() const {
  // @@protoc_insertion_point(field_get:CreateDOM.HingeJoint.limtLow)
  return limtlow_;
}
inline void HingeJoint::set_limtlow(float value) {
  
  limtlow_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.HingeJoint.limtLow)
}

// float limitHigh = 2;
inline void HingeJoint::clear_limithigh() {
  limithigh_ = 0;
}
inline float HingeJoint::limithigh() const {
  // @@protoc_insertion_point(field_get:CreateDOM.HingeJoint.limitHigh)
  return limithigh_;
}
inline void HingeJoint::set_limithigh(float value) {
  
  limithigh_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.HingeJoint.limitHigh)
}

// -------------------------------------------------------------------

// PrismaticJoint

// float limitLow = 1;
inline void PrismaticJoint::clear_limitlow() {
  limitlow_ = 0;
}
inline float PrismaticJoint::limitlow() const {
  // @@protoc_insertion_point(field_get:CreateDOM.PrismaticJoint.limitLow)
  return limitlow_;
}
inline void PrismaticJoint::set_limitlow(float value) {
  
  limitlow_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.PrismaticJoint.limitLow)
}

// float limitHigh = 2;
inline void PrismaticJoint::clear_limithigh() {
  limithigh_ = 0;
}
inline float PrismaticJoint::limithigh() const {
  // @@protoc_insertion_point(field_get:CreateDOM.PrismaticJoint.limitHigh)
  return limithigh_;
}
inline void PrismaticJoint::set_limithigh(float value) {
  
  limithigh_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.PrismaticJoint.limitHigh)
}

// -------------------------------------------------------------------

// DistanceJoint

// float distanceLow = 1;
inline void DistanceJoint::clear_distancelow() {
  distancelow_ = 0;
}
inline float DistanceJoint::distancelow() const {
  // @@protoc_insertion_point(field_get:CreateDOM.DistanceJoint.distanceLow)
  return distancelow_;
}
inline void DistanceJoint::set_distancelow(float value) {
  
  distancelow_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.DistanceJoint.distanceLow)
}

// float distanceHigh = 2;
inline void DistanceJoint::clear_distancehigh() {
  distancehigh_ = 0;
}
inline float DistanceJoint::distancehigh() const {
  // @@protoc_insertion_point(field_get:CreateDOM.DistanceJoint.distanceHigh)
  return distancehigh_;
}
inline void DistanceJoint::set_distancehigh(float value) {
  
  distancehigh_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.DistanceJoint.distanceHigh)
}

// -------------------------------------------------------------------

// BallAndSocketJoint

// float limitXLow = 1;
inline void BallAndSocketJoint::clear_limitxlow() {
  limitxlow_ = 0;
}
inline float BallAndSocketJoint::limitxlow() const {
  // @@protoc_insertion_point(field_get:CreateDOM.BallAndSocketJoint.limitXLow)
  return limitxlow_;
}
inline void BallAndSocketJoint::set_limitxlow(float value) {
  
  limitxlow_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.BallAndSocketJoint.limitXLow)
}

// float limitXHigh = 2;
inline void BallAndSocketJoint::clear_limitxhigh() {
  limitxhigh_ = 0;
}
inline float BallAndSocketJoint::limitxhigh() const {
  // @@protoc_insertion_point(field_get:CreateDOM.BallAndSocketJoint.limitXHigh)
  return limitxhigh_;
}
inline void BallAndSocketJoint::set_limitxhigh(float value) {
  
  limitxhigh_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.BallAndSocketJoint.limitXHigh)
}

// float limitY = 3;
inline void BallAndSocketJoint::clear_limity() {
  limity_ = 0;
}
inline float BallAndSocketJoint::limity() const {
  // @@protoc_insertion_point(field_get:CreateDOM.BallAndSocketJoint.limitY)
  return limity_;
}
inline void BallAndSocketJoint::set_limity(float value) {
  
  limity_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.BallAndSocketJoint.limitY)
}

// float limitZ = 4;
inline void BallAndSocketJoint::clear_limitz() {
  limitz_ = 0;
}
inline float BallAndSocketJoint::limitz() const {
  // @@protoc_insertion_point(field_get:CreateDOM.BallAndSocketJoint.limitZ)
  return limitz_;
}
inline void BallAndSocketJoint::set_limitz(float value) {
  
  limitz_ = value;
  // @@protoc_insertion_point(field_set:CreateDOM.BallAndSocketJoint.limitZ)
}

// -------------------------------------------------------------------

// D6Joint

// -------------------------------------------------------------------

// BodyPairFilter

// string bodyA = 1;
inline void BodyPairFilter::clear_bodya() {
  bodya_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BodyPairFilter::bodya() const {
  // @@protoc_insertion_point(field_get:CreateDOM.BodyPairFilter.bodyA)
  return bodya_.GetNoArena();
}
inline void BodyPairFilter::set_bodya(const ::std::string& value) {
  
  bodya_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateDOM.BodyPairFilter.bodyA)
}
#if LANG_CXX11
inline void BodyPairFilter::set_bodya(::std::string&& value) {
  
  bodya_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateDOM.BodyPairFilter.bodyA)
}
#endif
inline void BodyPairFilter::set_bodya(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bodya_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateDOM.BodyPairFilter.bodyA)
}
inline void BodyPairFilter::set_bodya(const char* value, size_t size) {
  
  bodya_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateDOM.BodyPairFilter.bodyA)
}
inline ::std::string* BodyPairFilter::mutable_bodya() {
  
  // @@protoc_insertion_point(field_mutable:CreateDOM.BodyPairFilter.bodyA)
  return bodya_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BodyPairFilter::release_bodya() {
  // @@protoc_insertion_point(field_release:CreateDOM.BodyPairFilter.bodyA)
  
  return bodya_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BodyPairFilter::set_allocated_bodya(::std::string* bodya) {
  if (bodya != NULL) {
    
  } else {
    
  }
  bodya_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bodya);
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.BodyPairFilter.bodyA)
}

// string bodyB = 2;
inline void BodyPairFilter::clear_bodyb() {
  bodyb_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BodyPairFilter::bodyb() const {
  // @@protoc_insertion_point(field_get:CreateDOM.BodyPairFilter.bodyB)
  return bodyb_.GetNoArena();
}
inline void BodyPairFilter::set_bodyb(const ::std::string& value) {
  
  bodyb_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateDOM.BodyPairFilter.bodyB)
}
#if LANG_CXX11
inline void BodyPairFilter::set_bodyb(::std::string&& value) {
  
  bodyb_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateDOM.BodyPairFilter.bodyB)
}
#endif
inline void BodyPairFilter::set_bodyb(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bodyb_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateDOM.BodyPairFilter.bodyB)
}
inline void BodyPairFilter::set_bodyb(const char* value, size_t size) {
  
  bodyb_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateDOM.BodyPairFilter.bodyB)
}
inline ::std::string* BodyPairFilter::mutable_bodyb() {
  
  // @@protoc_insertion_point(field_mutable:CreateDOM.BodyPairFilter.bodyB)
  return bodyb_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BodyPairFilter::release_bodyb() {
  // @@protoc_insertion_point(field_release:CreateDOM.BodyPairFilter.bodyB)
  
  return bodyb_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BodyPairFilter::set_allocated_bodyb(::std::string* bodyb) {
  if (bodyb != NULL) {
    
  } else {
    
  }
  bodyb_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bodyb);
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.BodyPairFilter.bodyB)
}

// -------------------------------------------------------------------

// BodyPairFilters

// repeated .CreateDOM.BodyPairFilter bodyPairs = 1;
inline int BodyPairFilters::bodypairs_size() const {
  return bodypairs_.size();
}
inline void BodyPairFilters::clear_bodypairs() {
  bodypairs_.Clear();
}
inline const ::CreateDOM::BodyPairFilter& BodyPairFilters::bodypairs(int index) const {
  // @@protoc_insertion_point(field_get:CreateDOM.BodyPairFilters.bodyPairs)
  return bodypairs_.Get(index);
}
inline ::CreateDOM::BodyPairFilter* BodyPairFilters::mutable_bodypairs(int index) {
  // @@protoc_insertion_point(field_mutable:CreateDOM.BodyPairFilters.bodyPairs)
  return bodypairs_.Mutable(index);
}
inline ::CreateDOM::BodyPairFilter* BodyPairFilters::add_bodypairs() {
  // @@protoc_insertion_point(field_add:CreateDOM.BodyPairFilters.bodyPairs)
  return bodypairs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CreateDOM::BodyPairFilter >*
BodyPairFilters::mutable_bodypairs() {
  // @@protoc_insertion_point(field_mutable_list:CreateDOM.BodyPairFilters.bodyPairs)
  return &bodypairs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CreateDOM::BodyPairFilter >&
BodyPairFilters::bodypairs() const {
  // @@protoc_insertion_point(field_list:CreateDOM.BodyPairFilters.bodyPairs)
  return bodypairs_;
}

// -------------------------------------------------------------------

// InstanceCollection

// string collection = 1;
inline void InstanceCollection::clear_collection() {
  collection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstanceCollection::collection() const {
  // @@protoc_insertion_point(field_get:CreateDOM.InstanceCollection.collection)
  return collection_.GetNoArena();
}
inline void InstanceCollection::set_collection(const ::std::string& value) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateDOM.InstanceCollection.collection)
}
#if LANG_CXX11
inline void InstanceCollection::set_collection(::std::string&& value) {
  
  collection_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateDOM.InstanceCollection.collection)
}
#endif
inline void InstanceCollection::set_collection(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateDOM.InstanceCollection.collection)
}
inline void InstanceCollection::set_collection(const char* value, size_t size) {
  
  collection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateDOM.InstanceCollection.collection)
}
inline ::std::string* InstanceCollection::mutable_collection() {
  
  // @@protoc_insertion_point(field_mutable:CreateDOM.InstanceCollection.collection)
  return collection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstanceCollection::release_collection() {
  // @@protoc_insertion_point(field_release:CreateDOM.InstanceCollection.collection)
  
  return collection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstanceCollection::set_allocated_collection(::std::string* collection) {
  if (collection != NULL) {
    
  } else {
    
  }
  collection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collection);
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.InstanceCollection.collection)
}

// .CreateDOM.Pose pose = 2;
inline bool InstanceCollection::has_pose() const {
  return this != internal_default_instance() && pose_ != NULL;
}
inline void InstanceCollection::clear_pose() {
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) delete pose_;
  pose_ = NULL;
}
inline const ::CreateDOM::Pose& InstanceCollection::pose() const {
  const ::CreateDOM::Pose* p = pose_;
  // @@protoc_insertion_point(field_get:CreateDOM.InstanceCollection.pose)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Pose*>(
      &::CreateDOM::_Pose_default_instance_);
}
inline ::CreateDOM::Pose* InstanceCollection::mutable_pose() {
  
  if (pose_ == NULL) {
    pose_ = new ::CreateDOM::Pose;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.InstanceCollection.pose)
  return pose_;
}
inline ::CreateDOM::Pose* InstanceCollection::release_pose() {
  // @@protoc_insertion_point(field_release:CreateDOM.InstanceCollection.pose)
  
  ::CreateDOM::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void InstanceCollection::set_allocated_pose(::CreateDOM::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.InstanceCollection.pose)
}

// .CreateDOM.Vec3 scale = 3;
inline bool InstanceCollection::has_scale() const {
  return this != internal_default_instance() && scale_ != NULL;
}
inline void InstanceCollection::clear_scale() {
  if (GetArenaNoVirtual() == NULL && scale_ != NULL) delete scale_;
  scale_ = NULL;
}
inline const ::CreateDOM::Vec3& InstanceCollection::scale() const {
  const ::CreateDOM::Vec3* p = scale_;
  // @@protoc_insertion_point(field_get:CreateDOM.InstanceCollection.scale)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Vec3*>(
      &::CreateDOM::_Vec3_default_instance_);
}
inline ::CreateDOM::Vec3* InstanceCollection::mutable_scale() {
  
  if (scale_ == NULL) {
    scale_ = new ::CreateDOM::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.InstanceCollection.scale)
  return scale_;
}
inline ::CreateDOM::Vec3* InstanceCollection::release_scale() {
  // @@protoc_insertion_point(field_release:CreateDOM.InstanceCollection.scale)
  
  ::CreateDOM::Vec3* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void InstanceCollection::set_allocated_scale(::CreateDOM::Vec3* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.InstanceCollection.scale)
}

// -------------------------------------------------------------------

// Collection

// repeated .CreateDOM.Node nodes = 1;
inline int Collection::nodes_size() const {
  return nodes_.size();
}
inline void Collection::clear_nodes() {
  nodes_.Clear();
}
inline const ::CreateDOM::Node& Collection::nodes(int index) const {
  // @@protoc_insertion_point(field_get:CreateDOM.Collection.nodes)
  return nodes_.Get(index);
}
inline ::CreateDOM::Node* Collection::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:CreateDOM.Collection.nodes)
  return nodes_.Mutable(index);
}
inline ::CreateDOM::Node* Collection::add_nodes() {
  // @@protoc_insertion_point(field_add:CreateDOM.Collection.nodes)
  return nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node >*
Collection::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:CreateDOM.Collection.nodes)
  return &nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node >&
Collection::nodes() const {
  // @@protoc_insertion_point(field_list:CreateDOM.Collection.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// Scene

// .CreateDOM.Vec3 gravity = 1;
inline bool Scene::has_gravity() const {
  return this != internal_default_instance() && gravity_ != NULL;
}
inline void Scene::clear_gravity() {
  if (GetArenaNoVirtual() == NULL && gravity_ != NULL) delete gravity_;
  gravity_ = NULL;
}
inline const ::CreateDOM::Vec3& Scene::gravity() const {
  const ::CreateDOM::Vec3* p = gravity_;
  // @@protoc_insertion_point(field_get:CreateDOM.Scene.gravity)
  return p != NULL ? *p : *reinterpret_cast<const ::CreateDOM::Vec3*>(
      &::CreateDOM::_Vec3_default_instance_);
}
inline ::CreateDOM::Vec3* Scene::mutable_gravity() {
  
  if (gravity_ == NULL) {
    gravity_ = new ::CreateDOM::Vec3;
  }
  // @@protoc_insertion_point(field_mutable:CreateDOM.Scene.gravity)
  return gravity_;
}
inline ::CreateDOM::Vec3* Scene::release_gravity() {
  // @@protoc_insertion_point(field_release:CreateDOM.Scene.gravity)
  
  ::CreateDOM::Vec3* temp = gravity_;
  gravity_ = NULL;
  return temp;
}
inline void Scene::set_allocated_gravity(::CreateDOM::Vec3* gravity) {
  delete gravity_;
  gravity_ = gravity;
  if (gravity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CreateDOM.Scene.gravity)
}

// repeated .CreateDOM.Node nodes = 2;
inline int Scene::nodes_size() const {
  return nodes_.size();
}
inline void Scene::clear_nodes() {
  nodes_.Clear();
}
inline const ::CreateDOM::Node& Scene::nodes(int index) const {
  // @@protoc_insertion_point(field_get:CreateDOM.Scene.nodes)
  return nodes_.Get(index);
}
inline ::CreateDOM::Node* Scene::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:CreateDOM.Scene.nodes)
  return nodes_.Mutable(index);
}
inline ::CreateDOM::Node* Scene::add_nodes() {
  // @@protoc_insertion_point(field_add:CreateDOM.Scene.nodes)
  return nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node >*
Scene::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:CreateDOM.Scene.nodes)
  return &nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node >&
Scene::nodes() const {
  // @@protoc_insertion_point(field_list:CreateDOM.Scene.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// PhysicsDOM

// repeated .CreateDOM.Node collections = 1;
inline int PhysicsDOM::collections_size() const {
  return collections_.size();
}
inline void PhysicsDOM::clear_collections() {
  collections_.Clear();
}
inline const ::CreateDOM::Node& PhysicsDOM::collections(int index) const {
  // @@protoc_insertion_point(field_get:CreateDOM.PhysicsDOM.collections)
  return collections_.Get(index);
}
inline ::CreateDOM::Node* PhysicsDOM::mutable_collections(int index) {
  // @@protoc_insertion_point(field_mutable:CreateDOM.PhysicsDOM.collections)
  return collections_.Mutable(index);
}
inline ::CreateDOM::Node* PhysicsDOM::add_collections() {
  // @@protoc_insertion_point(field_add:CreateDOM.PhysicsDOM.collections)
  return collections_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node >*
PhysicsDOM::mutable_collections() {
  // @@protoc_insertion_point(field_mutable_list:CreateDOM.PhysicsDOM.collections)
  return &collections_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node >&
PhysicsDOM::collections() const {
  // @@protoc_insertion_point(field_list:CreateDOM.PhysicsDOM.collections)
  return collections_;
}

// repeated .CreateDOM.Node scenes = 2;
inline int PhysicsDOM::scenes_size() const {
  return scenes_.size();
}
inline void PhysicsDOM::clear_scenes() {
  scenes_.Clear();
}
inline const ::CreateDOM::Node& PhysicsDOM::scenes(int index) const {
  // @@protoc_insertion_point(field_get:CreateDOM.PhysicsDOM.scenes)
  return scenes_.Get(index);
}
inline ::CreateDOM::Node* PhysicsDOM::mutable_scenes(int index) {
  // @@protoc_insertion_point(field_mutable:CreateDOM.PhysicsDOM.scenes)
  return scenes_.Mutable(index);
}
inline ::CreateDOM::Node* PhysicsDOM::add_scenes() {
  // @@protoc_insertion_point(field_add:CreateDOM.PhysicsDOM.scenes)
  return scenes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node >*
PhysicsDOM::mutable_scenes() {
  // @@protoc_insertion_point(field_mutable_list:CreateDOM.PhysicsDOM.scenes)
  return &scenes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::CreateDOM::Node >&
PhysicsDOM::scenes() const {
  // @@protoc_insertion_point(field_list:CreateDOM.PhysicsDOM.scenes)
  return scenes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace CreateDOM

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::CreateDOM::NodeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CreateDOM::NodeType>() {
  return ::CreateDOM::NodeType_descriptor();
}
template <> struct is_proto_enum< ::CreateDOM::GeometryType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CreateDOM::GeometryType>() {
  return ::CreateDOM::GeometryType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PhysicsDOM_2eproto__INCLUDED
