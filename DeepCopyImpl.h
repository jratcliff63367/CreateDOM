#ifndef DEEPCOPY_IMPL_H
#define DEEPCOPY_IMPL_H

// CreateDOM: Schema Generation tool written by John W. Ratcliff, 2017
// Warning:This source file was auto-generated by the CreateDOM tool. Do not try to edit this source file manually!
// The Google DOCs Schema Spreadsheet for this source came from: https://docs.google.com/spreadsheets/d/118I5kdu2XT-6wfCG044937xfEKDyX2oNg04G8Wqi6o0/edit?usp=sharing

#include "DeepCopy.h"
#include <string>
#include <vector>
#include <stdint.h>


namespace DEEP_COPY
{


// Forward declare the two types of string vector containers.
typedef std::vector< std::string > StringVector;
typedef std::vector< const char * > ConstCharVector;

// Declare the clone-object class for deep copies
// of objects by the implementation classes
// Not to be used with the base DOM classes;
// they do not support deep copies
// Also declares the virtual method to init the DOM contents.
class CloneObject
{
public:
	// Declare the default virtual clone method; not implemented for DOM objects; only used for the implementation versions.
	virtual CloneObject *clone(void) const { return nullptr; };
	// Declare the default initDOM method; which is only needed for some implementation objects.
	virtual void initDOM(void) {  };
};
typedef std::vector< Vec3 > Vec3VectorImpl; // Forward declare the 'Vec3' vector

class TestVec3Impl: public CloneObject
{
public:

	// Declare the constructor.
	TestVec3Impl() { }


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	TestVec3Impl(const TestVec3Impl &other)
	{
		*this = other;
	}


	virtual TestVec3 * getTestVec3(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new TestVec3Impl(*this);
	}

	// Declare and implement the deep copy assignment operator
	TestVec3Impl& operator=(const TestVec3Impl& other)
	{
		if (this != &other )
		{
			mName = other.mName;
			mPoints = other.mPoints;
		}
		return *this;
	}


	// Declare the helper method to return the DOM version of this class.
	TestVec3 *getDOM(void)
	{
		 return &mDOM;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		mDOM.name = mName.c_str(); // Assign the current string pointer.
		mDOM.pointsCount = uint32_t(mPoints.size()); // assign the number of items in the array.
		mDOM.points = mDOM.pointsCount ? &mPoints[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	TestVec3Impl(TestVec3Impl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	TestVec3Impl& operator=(TestVec3Impl&& other)
	{
		if (this != &other )
		{
			mName = other.mName;
			mPoints = other.mPoints;
		}
		return *this;
	}

	std::string	mName;   										// 
	Vec3VectorImpl   mPoints;  									// 
private:
	TestVec3 	mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
};


// Base class for all geometries
class GeometryImpl: public CloneObject
{
public:

	// Declare the constructor.
	GeometryImpl() { }


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	GeometryImpl(const GeometryImpl &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new GeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	GeometryImpl& operator=(const GeometryImpl& other)
	{
		if (this != &other )
		{
			mType = other.mType;
		}
		return *this;
	}


	// Declare the helper method to return the DOM version of this class.
	Geometry *getDOM(void)
	{
		 return &mDOM;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	GeometryImpl(GeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	GeometryImpl& operator=(GeometryImpl&& other)
	{
		if (this != &other )
		{
			mType = other.mType;
		}
		return *this;
	}

	GeometryType mType;											// 
private:
	Geometry 	mDOM; // Declare the DOM version.
};


// Defines a box geometry
class BoxGeometryImpl : public GeometryImpl
{
public:
	// Declare the constructor.
	BoxGeometryImpl()
	{
		GeometryImpl::mType = GT_BOX_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~BoxGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	BoxGeometryImpl(const BoxGeometryImpl &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Geometry *>(&mDOM); // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new BoxGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	BoxGeometryImpl& operator=(const BoxGeometryImpl& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(other);
			mWidth = other.mWidth;
			mDepth = other.mDepth;
			mHeight = other.mHeight;
		}
		return *this;
	}


	// Declare the helper method to return the DOM version of this class.
	BoxGeometry *getDOM(void)
	{
		 return &mDOM;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryImpl::getDOM()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.width = mWidth; // Simple member variable assignment to the DOM reflection: width
		mDOM.depth = mDepth; // Simple member variable assignment to the DOM reflection: depth
		mDOM.height = mHeight; // Simple member variable assignment to the DOM reflection: height
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	BoxGeometryImpl(BoxGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	BoxGeometryImpl& operator=(BoxGeometryImpl&& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(std::move(other));
			mWidth = other.mWidth;
			mDepth = other.mDepth;
			mHeight = other.mHeight;
		}
		return *this;
	}

	float  		mWidth{ 1 };  										// 
	float  		mDepth{ 1 };  										// 
	float  		mHeight{ 1 };   									// Dimensions of the box
private:
	BoxGeometry	mDOM; // Declare the DOM version.
};


// Defines a sphere geometry
class SphereGeometryImpl : public GeometryImpl
{
public:
	// Declare the constructor.
	SphereGeometryImpl()
	{
		GeometryImpl::mType = GT_SPHERE_GEOMETRY;
	}


	// Declare the virtual destructor.
	virtual ~SphereGeometryImpl()
	{
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	SphereGeometryImpl(const SphereGeometryImpl &other)
	{
		*this = other;
	}


	virtual Geometry * getGeometry(void) // Declare virtual method to return DOM version of base class.
	{
		return static_cast< Geometry *>(&mDOM); // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const override
	{
		return new SphereGeometryImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	SphereGeometryImpl& operator=(const SphereGeometryImpl& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(other);
			mRadius = other.mRadius;
		}
		return *this;
	}


	// Declare the helper method to return the DOM version of this class.
	SphereGeometry *getDOM(void)
	{
		 return &mDOM;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		// Initialize the DOM for the base class.
		GeometryImpl::initDOM();
		// Copy the elements from the base class DOM to our reflection DOM
		{
			Geometry *dom = static_cast< Geometry *>(&mDOM); // Get the DOM base class.
			*dom = *(GeometryImpl::getDOM()); // Assign the base class DOM components.
		}
		mDOM.type = mType; // Simple member variable assignment to the DOM reflection: type
		mDOM.radius = mRadius; // Simple member variable assignment to the DOM reflection: radius
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	SphereGeometryImpl(SphereGeometryImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	SphereGeometryImpl& operator=(SphereGeometryImpl&& other)
	{
		if (this != &other )
		{
			GeometryImpl::operator=(std::move(other));
			mRadius = other.mRadius;
		}
		return *this;
	}

	float  		mRadius{ 1 };   									// The radius of the sphere
private:
	SphereGeometry   mDOM; // Declare the DOM version.
};

typedef std::vector< GeometryImpl *> GeometryVectorImpl; // Forward declare the 'Geometry' vector for the implementation object pointers
typedef std::vector< Geometry *> GeometryVectorDOM; // Forward declare the 'Geometry' vector for the implementation object pointers

// Defines a single instance of a geometry
class GeometryInstanceImpl: public CloneObject
{
public:

	// Declare the constructor.
	GeometryInstanceImpl() { }


	// Declare the virtual destructor; cleanup any pointers or arrays of pointers
	virtual ~GeometryInstanceImpl()
	{
		for (auto &i:mGeometries) delete i; // Delete all of the object pointers in this array
	}


	// Declare the deep copy constructor; handles copying pointers and pointer arrays
	GeometryInstanceImpl(const GeometryInstanceImpl &other)
	{
		*this = other;
	}


	virtual GeometryInstance * getGeometryInstance(void) // Declare virtual method to return DOM version of base class.
	{
		return &mDOM; // return the address of the DOM.
	}


	// Declare the virtual clone method using a deep copy
	virtual CloneObject* clone() const
	{
		return new GeometryInstanceImpl(*this);
	}

	// Declare and implement the deep copy assignment operator
	GeometryInstanceImpl& operator=(const GeometryInstanceImpl& other)
	{
		if (this != &other )
		{
			mTestVec3 = other.mTestVec3;
			for (auto &i:mGeometries) delete i; // Delete all of the object pointers in this array
			mGeometries.clear(); // Clear the current array
			mGeometries.reserve(other.mGeometries.size()); // Reserve number of items for the new array
			for (auto &i:other.mGeometries) mGeometries.push_back( static_cast< GeometryImpl *>(i->clone())); // Deep copy object pointers into the array
		}
		return *this;
	}


	// Declare the helper method to return the DOM version of this class.
	GeometryInstance *getDOM(void)
	{
		 return &mDOM;
	}

	// Declare and implement the initDOM method
	virtual void initDOM(void) override
	{
		{
			TestVec3Impl *impl = static_cast< TestVec3Impl *>(&mTestVec3); // static cast to the implementation class.
			impl->initDOM(); // Initialize DOM components of member variable.
			mDOM.testVec3 = *impl->getDOM(); // Copy the DOM struct values.
		}
		mGeometriesDOM.clear();
		mGeometriesDOM.reserve( mGeometries.size() );
		for (auto &i:mGeometries)
		{
			i->initDOM();
			mGeometriesDOM.push_back( i->getGeometry() );
		}
		mDOM.geometriesCount = uint32_t(mGeometriesDOM.size()); // assign the number of items in the array.
		mDOM.geometries = mDOM.geometriesCount ? &mGeometriesDOM[0] : nullptr; // Assign the pointer array
	}


	// Declare the move constructor; handles copying pointers and pointer arrays
	GeometryInstanceImpl(GeometryInstanceImpl &&other)
	{
		*this = std::move(other);
	}

	// Declare and implement the move assignment operator
	GeometryInstanceImpl& operator=(GeometryInstanceImpl&& other)
	{
		if (this != &other )
		{
			mTestVec3 = other.mTestVec3;
			mGeometries = other.mGeometries;
			other.mGeometries.clear(); // Clear the 'other' array now that we have moved it
		}
		return *this;
	}

	TestVec3Impl mTestVec3;										// 
	GeometryVectorImpl mGeometries;								// The geometry associated with this instance
private:
	GeometryInstance mDOM; // Declare the DOM version.
// Declare private temporary array(s) to hold flat DOM version of arrays.
	GeometryVectorDOM mGeometriesDOM; // Scratch array for const char pointers.
};



} // End of DEEP_COPY namespace

#endif // End of Geometry
